%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}
\label{sect:evaluation} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reviewer: Section 8. The evaluation is very weak. Firstly, there are no research questions. Second, the expressiveness of AGL is argued but not evaluated. To demonstrate expressiveness, the paper could report on a couple of realistic case studies showing the extent to which AGL can capture all the necessary behaviour without resorting to code. For example, the approach seems limited to CRUD applications, so it is not clear whether more complex behaviour could be achieved without coding. 

In this section, we discuss an evaluation of \agl. We aim to point out that \agl~is both essentially expressive and practically usable. We follow the guidelines defined in~\cite{runesonGuidelinesConductingReporting2009} in order to  enhance the rigor of this experiment. The section closes a discussion with several remarks concerning the evaluation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Research Questions}
\label{subsect:researchQuestions} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%- How can we incorporate domain behaviors (that can be captured by UML Activity diagrams) into a domain model for a composition of both structural and behavioral aspects of the domain?
%
%- How can we extend a domain definition language like DCSL with new constructs to represent such domain behaviors?    

%We consider \agl incorporating \dcsl (\agldcsl) as a domain-specific language, thus we adapt from \cite{thakur2019role}~the three criteria in order to evaluate this language: (1)~\textit{Expressiveness}: the extent to which a language is able to express the properties of interest of its domain; (2)~\textit{Required coding level}: the extent to which the language allows expressing the underlying properties of the domain without too much hard coding; (3)~\textit{Constructibility}: the extent to which the language provides facilities for building complex specifications in a piecewise, incremental way. More specifically, the research questions for this study are posed as follows.
We evaluate the \agldcsl language, which incorporates \agl into \dcsl. We use the criteria defined in~\cite{thakur2019role} to evaluate \agldcsl as a domain-specific language. These criteria are \textit{expressiveness}, \textit{required coding level}, and \textit{constructibility}. They measure the extent to which a language can express the properties of interest of its domain, allows expressing the underlying properties of the domain without too much hard coding, and provides facilities for building complex specifications in a piecewise, incremental way (\resp). To achieve this goal, we pose the following research questions.

\begin{description}[labelindent=0.5cm,leftmargin=0.5cm]
%
\item[\textbf{RQ1.}] %How well does our method perform in representing domain models, compared to the existing DDD approaches?
How effective is our approach in representing domain models in comparison to existing DDD methods?
%
\item[\textbf{RQ2.}] How much effort is required to define unified domain model in \agldcsl for generating DDD software?
%
%\item[\textbf{RQ3.}] Is our method applicable to developing real-world software?
%
\end{description}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Case Study Design}
\label{subsect:caseDesign} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent \textit{\textbf{Setup.}} 
%We choose to analyze the development of three software applications (apps) coming from real-world needs. These apps are as follows: (1)~\courseman, (2)~\processman, and (3)~\orderman. While the third app has been explained as in Section~\ref{sect:caseStudyToolSupport}, we further explain the remaining apps as follows.	
We have selected three software applications (apps) that are derived from real-world requirements for our analysis. These applications are \courseman, \processman, and \orderman. Although we have already elaborated on the third app in Section~\ref{sect:caseStudyToolSupport}, we will provide further explanations on the other two apps.

%The first app is called \courseman, a software application for course management in the university. The domain \wrt the case is a relatively complex, real world problem domain and a suitable subject for the application of DDD. The domain is also a familiar and generic problem domain in the academic institutions, that has been studied in the literature~\cite{ajanovskiIntegrationCourseEnrolment2013,omahonyRecommenderSystemOnline2007,le_domain_2018}.
The first application, \courseman, is a software designed for managing courses in a university. The problem domain related to this case is relatively complex, representing a real-world problem domain that is well-suited for applying DDD. Additionally, this domain is a common and generic problem domain in academic institutions that has been studied in the literature~\cite{ajanovskiIntegrationCourseEnrolment2013,omahonyRecommenderSystemOnline2007,le_domain_2018}.

%The second app is called \processman that manages the processes of the Faculty of IT at Hanoi University for teaching subjects (a.k.a course modules) to students every semester and formally assessing the students’ performances. This app has been studied and realized in DCSL as reported in our previous work~\cite{le_generative_2018}. For this experiment, the current version of this app is developed using the AGL-based method.
%%, thus the case is only used for evaluating structural aspects.
The second app, named \processman, manages the processes of the Faculty of IT at Hanoi University for teaching subjects (\aka course modules) to students every semester and formally assessing their performances. This app was previously studied and developed using \dcsl, as reported in our earlier work~\cite{le_generative_2018}. For this experiment, we have developed the current version of this app using the AGL-based method.

\vspace{0.1cm}
\noindent\textit{\textbf{Measure.}} 
%For measuring expressiveness, we consider our method as a realization for the DDD patterns (\textit{Entity}, \textit{Aggregate}, \textit{Value Object} and \textit{Service}) as explained in~\cite{evans_domain-driven_2004}. Thus, we measure how our language could be mapped to the patterns. Further, we compare our language to the existing DDD approaches: (1)~the annotation-based extensions of two DDD frameworks and (2)~the commonly-used third-party annotation sets. We label the annotation-based extensions of the two frameworks as follows: ApacheIsis\footnote{with the new name 'causeway' since March 26 2023}~\cite{apache_causeway_2023} as AL and OpenXava~\cite{noauthor_openxava_2016} as XL. 
To evaluate the expressiveness of our method, we view it as an implementation of DDD patterns such as \textit{Entity}, \textit{Aggregate}, \textit{Value Object} and \textit{Service} (as described in~\cite{evans_domain-driven_2004}). Therefore, we measure how well our language can be mapped to these patterns. Additionally, we compare our approach to existing DDD methods, including two annotation-based extensions of DDD frameworks. The two frameworks that support commonly used third-party annotation sets are labeled as AL for ApacheIsis\footnote{with the new name 'causeway' since March 26 2023}~\cite{apache_causeway_2023} and XL for OpenXava~\cite{noauthor_openxava_2016}.

%We could employ \agldcsl’s terms as the base for evaluation because they correspond to the essential terms that are used in the relevant modelling and OOPL literatures, and there has been no other annotation-based \agldcsl that supports a similar set of terms.
%
%Using the DCSL’s terms, we analysed the relevant technical documentations of AL, XL, and DDD patterns to identify the language constructs that are either the same as or equivalent to the primitives or combinations thereof that make up each term. We also made some effort in our analysis to quantify the correspondences.

%We evaluate \agldcsl’s expressiveness in two aspects: structural modeling and behavioral modeling. For structural modelling, similarly to our previous work on \dcsl~\cite{le_domain_2018},  we use the four \dcsl’s terms as criteria: \textit{domain class}, \textit{domain field}, \textit{associative field}, and \textit{domain method}. For behavioural modelling, we compare our language with UML Activity diagram (labeled as AD) since the diagram has been widely used to capture domain behaviors.
We evaluate \agldcsl’s expressiveness in two aspects: structural modeling and behavioral modeling. In terms of structural modeling, we use the four criteria of \textit{domain class}, \textit{domain field}, \textit{associative field}, and \textit{domain method}, which we previously used in our work on \dcsl~\cite{le_domain_2018}. In terms of behavioral modeling, we compare our language to UML Activity diagram (labeled as AD), which is a widely-used method for capturing domain behaviors.

%For behavioral aspects, \agl~is able to express the five essential UML activity modeling patterns, as explained in Section~\ref{sect:behaviorPatterns}. Therefore, any domain behavior captured by an activity diagram with these basic constructs could be expressed in \agl.

%Based on the expressiveness evaluation result, we use as criteria three domain terms (domain class, domain field and associative field) that are supported by DCSL, AL and XL.

%For measuring required level of coding, we also evaluate it in two aspects: structural modeling and behavioral modeling. For structural modeling, we follow exactly the evaluation reported in our previous work~\cite{le_domain_2018}. We use two sub-criteria: max-locs (max number of lines of code) and typical-locs (typical number of locs). The lower the values of these the better. Since \dcsl, AL, and XL are all internal to a base OOPL, we might consider annotation property as a loc. Thus, max-locs (resp. typical-locs) is the maximum (resp. typical) number of properties needed to express a typical domain term. 
%%The typical number of properties include only properties that either do not have a default value or are typically assigned to a value different from the default. 
%For example, to specify in \dcsl a typical domain field (say \attribn{Student.name}) maximally (resp. typically) requires these (resp. one of these) three \attribn{DAttr}’s properties: length, min, max.
For measuring the required coding level~(RCL), we also evaluate it in two aspects: structural modeling and behavioral modeling. In terms of structural modeling, we follow the approach reported in our previous work~\cite{le_domain_2018}, using two sub-criteria: maximum number of lines of code (max-locs) and typical number of lines of code (typical-locs). The lower the values of these criteria, the better. Since DCSL, AL, and XL are all based on a host OOPL, we consider an annotation property as a line of code. Therefore, max-locs (typical-locs) represent the maximum (typical) number of properties needed to express a typical domain term. For example, to specify a typical domain field such as \attribn{Student.name} in \dcsl, we need a maximum of three DAttr's properties (\clazz{length}, \clazz{min}, and \clazz{max}) or typically one of these properties.


%For measuring RCL from the behavioral aspect, since \agl, to the best of our knowledge, is the first aDSL of its type, We cannot compare the required level of coding of \agl (\agl's RLC) with other languages. Thus, we measure the \agl's RLC using the ``compactness'' of the language's CSM (see Section~\ref{sect:agl}). This is determined based on the reduction in the number of features in the CSM through the transformation ASM $\rightarrow$ CSM$_T$. More precisely, \agl's RLC is the percentage of the number of CSM$_T$'s features over the number of ASM's. The smaller this percentage, the higher the reduction in the number of features in the CSM and, thus, the more compact the CSM. For this evaluation, we also consider quantitative measures of the number of domain patterns (modules) that have been employed (defined) for developing the underlying apps. The more patterns are employed, the less effort required to obtain the software (by composing them).
To measure RCL from the behavioral perspective, we cannot compare \agl's RCL with that of other languages as \agl is the first aDSL of its kind. Hence, we assess \agl's RCL based on the compactness of the language's CSM, as explained in Section~\ref{sect:agl}. This is determined by the reduction in the number of features in the CSM via the transformation ASM $\rightarrow$ CSM$_T$. Specifically, \agl's RCL is the percentage of the number of CSM$_T$'s features over the number of ASM's. A smaller percentage indicates a higher reduction in the number of features in the CSM and, consequently, a more compact CSM. Additionally, we consider quantitative measures of the number of domain patterns (modules) employed (defined) for building the underlying apps. The more patterns are employed, the less effort is required to obtain the software. %(by composing them).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Results}
\label{subsect:results} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section explains the results of our experiment, answering the raised research questions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Expressiveness} 
\label{sect:eval-expressiveness}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent \textbf{
%RQ1. How well does our method perform in representing domain models, compared to the existing DDD approaches?
RQ1. How effective is our approach in representing domain models in comparison to existing DDD methods?
}	

%As shown in Table~\ref{tab:eval_expr_agl}(A) our language and the existing DDD approaches (AL and XL) partly realize the DDD patterns~\cite{evans_domain-driven_2004}. Note that within DDD the notion of a service is referred to as a building block: ``When a significant process or transformation in the domain is not a natural responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as standalone interface declared as a SERVICE. Define the interface in terms of the language of the model and make sure the operation name is part of the UBIQUITOUS LANGUAGE. Make the SERVICE stateless''~\cite{evans_domain-driven_2004}. The first three patterns within our method are realized by the aDSL \dcsl, while the other works realize them based on the UML Class diagram enriched by OCL. %
%%
%%The last pattern could be realized by UML Activity diagram, %
%%%however, it lacks a mechanism to compose the behavioral diagrams with other structural diagrams. 
%%however, it requires additional mechanisms such as fUML~\cite{omg_semantics_2021} and OCL~\cite{omg_object_2014} to obtain an integrated semantics of the behavioral diagrams with other structural diagrams (one of which describes the domain model).
%While the UML Activity diagram can be used to implement the final DDD pattern, it necessitates the adoption of supplementary mechanisms like fUML~\cite{omg_semantics_2021} and OCL~\cite{omg_object_2014} to achieve an integrated semantic model of the behavioral and structural diagrams (one of which depicts the domain model). 
%%
%Services within our approach are represented as activity models, each of which consists of an activity domain class (expressed in \dcsl) and an activity graph (specified in \agl).
As presented in Table~\ref{tab:eval_expr_agl}(A), our language and the existing DDD approaches (AL and XL) partially implement the DDD patterns~\cite{evans_domain-driven_2004}. It should be noted that in DDD, the concept of a service is referred to as a building block and is defined as follows: ``When a significant process or transformation in the domain is not a natural responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as a standalone interface declared as a SERVICE. Define the interface in terms of the language of the model and make sure the operation name is part of the UBIQUITOUS LANGUAGE. Make the SERVICE stateless''~\cite{evans_domain-driven_2004}. The first three patterns in our method are implemented using the aDSL \dcsl, while the other approaches implement them using the UML Class diagram enriched by OCL. Although the UML Activity diagram can be utilized to implement the final DDD pattern, it requires additional mechanisms such as fUML~\cite{omg_semantics_2021} and OCL~\cite{omg_object_2014} to obtain an integrated semantic model of the behavioral and structural diagrams (one of which represents the domain model). Within our approach, services are represented as activity models, each consisting of an activity domain class (expressed in \dcsl) and an activity graph (specified in \agl).

\vspace{-0.3cm}
\begin{table}[ht]
	\small
	\caption{(A-left) Criteria 1: The expressiveness criteria based on DDD patterns; (B-right) Criteria 2: The expressiveness criteria based on domain meta-concepts}
	\label{tab:eval_expr_agl}
	\begin{tabular}{llllllllll}
		\hline
		Criteria 1 & AGL+            & AL         & XL         & AD         & Criteria 2 & AGL+     & AL         & XL         & AD         \\ \hline
		Entity \& Aggregate & DomainClass (DC)          & $\surd$ & $\surd$ & \bf{\ding{55}} & DC         & \textbf{1/1} & 1/1        & 0/1        & \bf{\ding{55}} \\
		& DomainField (DF)         &  $\surd$         & $\surd$     & \bf{\ding{55}} & DF             & \textbf{8/8} & 4/8        & 5/8        & \bf{\ding{55}} \\
		& AssociativeField (AF)     & $\surd$ & $\surd$ & \bf{\ding{55}} & AF    & \textbf{7/7} & 0/7        & 1/7        & \bf{\ding{55}} \\
		& DomainMethod (DM)        & $\surd$          & $\surd$          & \bf{\ding{55}} & DM            & $\surd$            & \bf{\ding{55}} & \bf{\ding{55}} & \bf{\ding{55}} \\
		Value Object        & ImmutableDomainClass & $\surd$ & $\surd$ & \bf{\ding{55}} & ADC & $\surd$            & \bf{\ding{55}} & \bf{\ding{55}} & $\surd$          \\
		Service      & ActivityDomainClass (ADC) & \bf{\ding{55}} & \bf{\ding{55}} & $\surd$          &                         &              &            &            &            \\ \cline{1-10}
	\end{tabular}
\end{table}

%Table~\ref{tab:eval_expr_agl}(B) presents the evaluation table of \agldcsl and the existing DDD approaches (AL, XL, and AD). Each fraction in this table is a ratio of the number of essential properties of the meta-attribute involved in the underlying meta-concept that are supported by AL or XL. The denominator of the ratio is the total number of essential properties. %
%Here, the essential properties \wrt the meta-attribute \clazz{DAttr}, that have been defined in our previous work~\cite{le_domain_2018} as the first catalog of domain structural patterns, consist of 8 properties: \clazz{unique}, \clazz{optional}, \clazz{mutable}, \clazz{id}, \clazz{auto}, \clazz{length}, \clazz{min}, and \clazz{max}.
%%
%Therefore, the ratio 4/8 for AL \wrt the term Domain Field means that AL only supports 4 out of the total of 8 properties of the meta-attribute \clazz{DAttr} (used in Domain Field). The four AL's properties are 
%%\clazz{Property}.\attribn{mustSatisfy},
%\clazz{Column}.\attribn{allowsNull}, 
%\clazz{Property}.\attribn{editing}, 
%\clazz{PrimaryKey}.\attribn{value}, and 
%\clazz{Column}.\attribn{length}. %
%%
%Similarly, the essential properties \wrt the meta-attribute \clazz{DAssoc} include 7 properties: \clazz{ascName}, \clazz{ascType}, \clazz{role}, \clazz{endType}, \clazz{associate.type}, \clazz{associate.cardMin}, and \clazz{associate.cardMax}. %
%%
%Note that the ratio aims to evaluate the current works from structural aspect, thus, this evaluation step coincides with the one for \dcsl, reported in our previous work~\cite{le_domain_2018}. %
%%
%Additionally, for a more detailed explanation of this point, we would refer the reader to Appendix D of our technical report~\cite{dang2023aglTechReport}.


Table~\ref{tab:eval_expr_agl}(B) presents the evaluation results for \agldcsl and existing DDD approaches (AL, XL, and AD). Each fraction in the table represents the ratio of the number of essential properties of the meta-attribute involved in the underlying meta-concept that are supported by AL or XL. The denominator of the ratio is the total number of essential properties. In our previous work~\cite{le_domain_2018}, we defined the essential properties \wrt the meta-attribute \clazz{DAttr}, which includes eight properties: \clazz{unique}, \clazz{optional}, \clazz{mutable}, \clazz{id}, \clazz{auto}, \clazz{length}, \clazz{min}, and \clazz{max}. Therefore, a ratio of 4/8 for AL \wrt the term \clazz{DomainField} means that AL only supports four out of the eight properties of the meta-attribute \clazz{DAttr} that are used in \clazz{DomainField}. These four properties are \clazz{Column}.\attribn{allowsNull}, 
\clazz{Property}.\attribn{editing}, 
\clazz{PrimaryKey}.\attribn{value}, and 
\clazz{Column}.\attribn{length}. Similarly, there are seven essential properties \wrt the meta-attribute \clazz{DAssoc}: \clazz{ascName}, \clazz{ascType}, \clazz{role}, \clazz{endType}, \clazz{associate.type}, \clazz{associate.cardMin}, and \clazz{associate.cardMax}. It's worth to note that the ratio aims to evaluate the current approaches from a structural aspect, which coincides with the evaluation step for \dcsl reported in our previous work~\cite{le_domain_2018}. For a more detailed explanation is presented in Appendix~D.

As shown in Table~\ref{tab:eval_expr_agl}(B), \agldcsl is more expressive than AL and XL in both structural and behavioral aspects. These two languages only partially support structural aspect and they do not support behavioral aspect. In particular, AL and XL's support for AssociativeField is very limited compared to \agldcsl. AD's expressiveness of domain behaviors is better than \agl, but again the behavioral model lacks an explicit connection to structural models.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Required Coding Level} \label{sect:eval-rcl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent \textbf{RQ2. How much effort is required to define unified domain model in \agldcsl for generating DDD software?}

%Reviewer: Third, compactness is evaluated by comparing the concrete and abstract syntax representations of the DSL. This is fine, although it would have been more convincing to compare with other approaches (not necessarily based on aDSLs). 

%It is clear from Figures~\ref{fig:agl-abstractSyntax} and~\ref{fig:agl-txtSyntax} that \agl's RCL is $\frac{3}{10}=30\%$, as defined in Section~\ref{subsect:caseDesign}. Specifically, Figure~\ref{fig:agl-abstractSyntax} shows that the number of meta-concepts of the ASM involved in the transformation is 10. These exclude the four meta-concepts (\clazz{DomainClass}, \clazz{Module}, \clazz{ModuleService}, and \clazz{State}) that are transferred directly to CSM$_T$. On the other hand, Figure~\ref{fig:agl-txtSyntax} shows that three meta-concepts result from the transformation (including \clazz{AGraph}, \clazz{ANode}, and \clazz{MAct}). Therefore, \agl~can have a CSM that significantly reduces the number of meta-concepts required to write an \agl specification to only one-third. 
It is evident from Figures~\ref{fig:agl-abstractSyntax} and~\ref{fig:agl-txtSyntax} that \agl's RCL is $\frac{3}{10}=30\%$, as defined in Section~\ref{subsect:caseDesign}. Figure~\ref{fig:agl-abstractSyntax} shows that there are 10 meta-concepts of ASM involved in the transformation, excluding the four meta-concepts (\clazz{DomainClass}, \clazz{Module}, \clazz{ModuleService}, and \clazz{State}) that are directly transferred to CSM$_T$. Figure~\ref{fig:agl-txtSyntax}, on the other hand, shows that the transformation results in only three meta-concepts, including \clazz{AGraph}, \clazz{ANode}, and \clazz{MAct}. Therefore, \agl enables the creation of a CSM that reduces the number of required meta-concepts for writing an \agl specification to only one-third.


{\makeatletter
	\let\par\@@par
	\par\parshape0
	\everypar{}
	\begin{wraptable}{r}{7.2cm}
		\vspace{-0.5cm}
		\caption{Statistics of Behavior Patterns and Modules\\for \courseman, \processman, and \orderman}
		\vspace{0.1cm}
		\label{tab:eval_patNum}
		\begin{tabular}{lcc}
			\hline
			& Patterns & Modules \\ \hline
			\courseman  & 3                  & 6                 \\ 
			\processman & 5                  & 37                \\
			\orderman   & 5                  & 13                \\ \hline
		\end{tabular}
	\end{wraptable}
%
%Table~\ref{tab:eval_patNum} shows the number of domain behavior patterns (modules) that are employed (defined) for obtaining the apps \courseman, \processman, and \orderman. While the number of modules points out the complexity of the software, the number of domain behavior patterns highlights the applicability of our first catalog of the patterns as well as the less effort of the developer to manually code the software.
Table~\ref{tab:eval_patNum} shows the number of domain behavior patterns (modules) employed (defined) for obtaining the apps \courseman, \processman, and \orderman. While the number of modules indicates the complexity of the software, the number of domain behavior patterns highlights the applicability of our first catalog of patterns as well as the reduced effort required by developers to manually code the software.\par
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion} 
\label{sect:eval-discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let us conclude our evaluation with a number of remarks on the \agl-based method as follows.

%\textbf{\textit{Integration into a software development process}} is essential for the dissemination of our method in practice. We argue that our method is particularly suited for integration into iterative \cite{larman_applying_2004} and agile~\cite{beck_manifesto_2017} development processes. In particular, the development team (which includes domain experts and developers) would employ our tool to work together on developing the unified domain model in an incremental fashion, and then generating the software from this model. The domain experts give feedback for the model via the software GUI and the update cycle continues. The generated software prototypes can be used as the intermediate releases for the final software. %
%%
%Further, in both processes, tools and techniques from \abbrv{model-driven software engineering}{MDSE} would be applied to enhance productivity and tackle platform variability. In particular, we would apply PIM-to-PSM model transformation~\cite{kent_model_2002,brambilla_model-driven_2012} to automatically generate our unified domain model from a high-level one that is constructed using a combination of UML Class and Activity diagrams.
\textbf{\textit{Integrating the \agldcsl-based method into the software development process}} is crucial for its practical implementation. The method is suitable for integration into iterative~\cite{larman_applying_2004} and agile~\cite{beck_manifesto_2017} development processes. In this process, the development team, consisting of domain experts and developers, would utilize the \agldcsl tool to work collaboratively on developing the unified domain model incrementally and generating software from this model. The domain experts provide feedback on the model via the software GUI, and the update cycle continues. The software prototypes generated can be used as intermediate releases for the final software. Additionally, in both processes, \textit{model-driven software engineering~(MDSE)} tools and techniques can be applied to increase productivity and address platform variability. Specifically, PIM-to-PSM model transformation~\cite{kent_model_2002,brambilla_model-driven_2012} would be utilized to automatically generate the unified domain model from a high-level one constructed using a combination of UML Class and Activity diagrams.

%\textbf{\textit{The usability of the software GUI}}, from the domain expert's viewpoint, plays a role in the usability of our method. Although in this paper we did not discuss this issue, we would argue in favor of two aspects of the software GUI, namely simplicity and consistency, which contribute towards its learnability~\cite{folmer_architecting_2004}. Our plan is to fully evaluate GUI usability in future work. First, the GUI design is simple because, as discussed in~\cite{le_domain_2018}, it directly reflects the domain class structure. Clearly, this is the most basic representation of the domain model. Second, the GUI is consistent in its presentation of the module view and the handling of the user actions performed on it. Consistent presentation is due to the application of the reflective layout to the views of all modules. Consistent handling is due to the fact that a common set of module actions (see Section~\ref{sect:actSemantics}) are made available on the module view.
\textit{\textbf{The usability of the software GUI}} is essential from the domain expert's perspective and impacts the usability of our method. Although we did not discuss this issue in this paper, we believe that two aspects of the software GUI - simplicity and consistency - contribute to its learnability~\cite{folmer_architecting_2004}. We plan to evaluate GUI usability thoroughly in future work. The GUI design is simple because it directly reflects the domain class structure, as discussed in~\cite{le_domain_2018}. This representation is the most fundamental of the domain model. In addition, the GUI is consistent in presenting the module view and handling user actions performed on it. Consistency in presentation is achieved by applying a reflective layout to all module views, while consistency in handling is achieved by providing a common set of module actions (see Section~\ref{sect:actSemantics}) on the module view.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Constructibility} 
\label{sect:eval-construct}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textbf{\textit{Constructibility}.} For \agl, the language's embedment in the host OOPL allows it to take for granted the general construction capabilities of the host language platform and those provided by modern IDEs (e.g., Eclipse). More specifically, using an IDE a developer can syntactically and statically check an \agl specification at compile time. In addition, she can easily import and reference a domain class in the AGL specification and have this specification automatically updated (through refactoring) when the domain class is renamed or relocated.
%
%More importantly, the AGL specfication can be constructed incrementally with the domain model. This is due to a property of our activity graph model (discussed in Section~\ref{sect:agl}) that the nodes and edges of an activity graph are mapped to the domain classes and their associations.
%
Further, we would develop automated techniques to ease the construction of the AGL specification. Intuitively, for example, a technique would be to generate a default AGL specification for an activity and to allow the developer to customize it. We plan to investigate techniques such as this as part of future work.

%Reviewer:  I would suggest adding one paragraph discussing the generality of AGL. 
%What would be the effort to implement the approach in other host languages? 
%What features must a host language have to allow implementing DSCL/AGL on top of it?

%\textbf{\textit{Generality}.} The core of our mechanism to incorporate behaviors for a unified domain model is to employ domain behavior patterns in MOSA. Domain behavior patterns and MOSA are basically dependent from the implementation language. Therefore, our method could be realized by another OOPL as an alternative for Java. The language should support the annotation mechanism (like in Java) so that we could implement \agldcsl on top of it. As an alternative to the use of annotation-based DSLs, we could define external DSLs to realize our method. Such DSLs would be realized based on current language frameworks such as Xtext~\cite{bettini_implementing_2016}, GEMOC~\cite{combemale_language_2017}, and Monticore~\cite{rumpe_monticore_2021}.
\textbf{\textit{Generality}.} The core of our mechanism for incorporating behaviors into a unified domain model is to use domain behavior patterns in MOSA. Since domain behavior patterns and MOSA do not depend on the implementation language, our method could be implemented using another object-oriented programming language as an alternative to Java. The language chosen should support the annotation mechanism, like Java, so that \agldcsl could be implemented on top of it. Alternatively, instead of using annotation-based DSLs, we could define external DSLs to implement our method. These DSLs could be implemented using current language frameworks such as Xtext~\cite{bettini_implementing_2016}, GEMOC~\cite{combemale_language_2017}, and Monticore~\cite{rumpe_monticore_2021}.



