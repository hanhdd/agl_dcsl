%\newpage
\section{Threats to Validity} \label{sect:threats}
This section discusses threats to validity of both our proposed method, the evaluation method. We organize threats according to the following four categories of validity in~\cite{runeson2009guidelines}: construct validity, internal validity, external validity and reliability.

\subsection{Evaluation Method}
%
%\subsection{Discussion} \label{sect:eval-discussion} %
%We present below a number of remarks both generally about \agl~and our method and specifically about our evaluation.

\textbf{\textit{The composition of the configured unified model}} in terms of the unified model and an activity graph model (see Section~\ref{sect:agl}) follows a language composition approach described by Kleppe~\cite{kleppe_software_2008}. In this approach, the composition is formed by language referencing. That is, one component language (called \textit{active language}) references the elements of the other component language (called the \textit{passive language}). In our method, \agl~is the active language and \dcsl~is the passive one.

\textbf{\textit{The evolution of languages}} (including both \agl~and \dcsl) is inevitable if we are to support 
more expressive domain modeling requirements. We discuss in~\cite{le_domain_2018} how \dcsl~is currently expressive only \wrt an essential set of domain requirements that are found to commonly shape the domain class design. We argue that \dcsl~would evolve to support other structural features. For \agl, its ASM would be extended to support other activity modeling features, such as activity group~\cite[p. 405]{omg_unified_2017}.

\textbf{\textit{The selection of the unified modeling patterns}} used in our expressiveness evaluation is based on the UML class and activity modeling languages that we currently use to construct the configured unified model. A question then arises as to the adaptability of our method to other behavioral modeling languages (\eg state machine and sequence diagram). We plan to investigate this as part of future work.
%
\subsection{Construct validity}
In our case study, we have assumed that there are no misinterpretations of the domain requirements that would lead to unsatisfactory. In practice, the designer and domain expert would need to work closely with each other to ensure that the models are satisfactory.
Our method helped mitigate the threat of misinterpretation by allowing combined the class model with a behavioral model (e.g. a UML Activity
diagram) into domain models constructing a configured unified domain model within a domain-driven architecture.
%
\subsection{Internal validity}
A concern with the internal validity of our case study is whether the requirements of the underlying apps (\courseman, \processman, and \orderman) sufficiently cover the activity graph that were discussed in Section~\ref{fig:agl-abstractSyntax}. We incorporate in our definition of the metamodel ASM for AGL's abstract syntax and create a mapping table for Node objects, Edge objects, ModuleAct objects of the activity graph. We translate a behavior specification in the UML Activity diagram into a corresponding specification defined as a combination of pattern solutions (domain behavior patterns), expressed by an AGL specifciation. Our view is that although these are not the only design patterns in the five essential UML activity modeling patterns, our pattern-based approach could support domain behaviors that are specified by a UML Activity with basic constructs corresponding to these patterns.
%
\subsection{External validity}
Threats to external validity of our method include those that impact how our method is applicable to the development of other MSA-based and DDD-based software that have similar characteristics. The first threat stems from a fact that our method is applicable to systems that are designed based on MDSA (a combination of MSA and DDD). The second threat is the generality of the case study. One would argue whether or not the case study that we selected is representative of the real-world ones. Our pattern-based approach helps mitigate this threat because it is based on the well-known software design principle to keep the patterns generic.