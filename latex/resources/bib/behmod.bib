@IEEEtranBSTCTL{ieee_bst_control,
  CTLuse_forced_etal = "yes",
  CTLmax_names_forced_etal = "2",
  CTLnames_show_etal = "1"
}

@article{van_deursen_domain-specific_2000,
	title = {Domain-specific {Languages}: {An} {Annotated} {Bibliography}},
	volume = {35},
	issn = {0362-1340},
	shorttitle = {Domain-specific {Languages}},
	optdoi ={10.1145/352029.352035},
	abstract = {We survey the literature available on the topic of domain-specific languages as used for the construction and maintenance of software systems. We list a selection of 75 key publications in the area, and provide a summary for each of the papers. Moreover, we discuss terminology, risks and benefits, example domain-specific languages, design methodologies, and implementation techniques.},
	number = {6},
	journal = {SIGPLAN Not.},
	author = {van Deursen, Arie and Klint, Paul and Visser, Joost},
	month = jun,
	year = {2000},
	pages = {26--36},
	optfile = {2000-domain-specific-languages-bibliography.pdf:/data/docs/ref/seng/dsl/2000-domain-specific-languages-bibliography.pdf:application/pdf;ACM Full Text PDF:/data/docs/refman/storage/6RKSIWFX/van Deursen et al. - 2000 - Domain-specific Languages An Annotated Bibliograp.pdf:application/pdf}
}

@book{arnold_java_2005,
	edition = {4th},
	title = {The {Java} {Programming} {Language}},
	volume = {2},
	publisher = {Addison-wesley Reading},
	author = {Arnold, Ken and Gosling, James and Holmes, David},
	year = {2005},
	optfile = {[PDF] from beastweb.org:/data/docs/refman/storage/833BGP3B/Arnold et al. - 2000 - The Java programming language.pdf:application/pdf}
}

@article{krasner_description_1988,
	title = {A {Description} of the {Model}-{View}-{Controller} {User} {Interface} {Paradigm} in the {Smalltalk}-80 {System}},
	volume = {1},
	number = {3},
	journal = {{J.} of object-oriented programming},
	author = {Krasner, Glenn E. and Pope, Stephen T.},
	year = {1988},
	pages = {26--49},
	optfile = {[PDF] from googlecode.com:/data/docs/refman/storage/EZSXMZ54/Krasner et al. - 1988 - A description of the model-view-controller user in.pdf:application/pdf}
}

@inproceedings{fuggetta_software_2014,
	address = {New York, NY, USA},
	series = {{FOSE} 2014},
	title = {Software {Process}},
	isbn = {978-1-4503-2865-4},
	doi = {10.1145/2593882.2593883},
	abstract = {This paper is a travelogue of Software Process research and practice in the past 15 years. It is based on the paper written by one of the authors for the FOSE Track at ICSE 2000. Since then, the landscape of Software Process research has significantly evolved: technological breakthroughs and market disruptions have defined new and complex challenges for Software Engineering researchers and practitioners.   In this paper we provide an overview of the current status of research and practice, highlight new challenges, and provide a non-exhaustive list of research issues that, in our view, need to be tackled by future research work.},
	booktitle = {Proceedings of the on {Future} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Fuggetta, Alfonso and Di Nitto, Elisabetta},
	year = {2014},
	keywords = {Empirical studies, Software development, Agile Software De- velopment, Social Fac- tors in Software Development, Software Development Environments, Software Process},
	pages = {1--12},
	file = {Fuggetta and Di Nitto - 2014 - Software Process.pdf:/data/docs/refman/storage/CE7NEVDH/Fuggetta and Di Nitto - 2014 - Software Process.pdf:application/pdf}
}

@inproceedings{coutaz_pac:_1987,
	title = {{PAC}: {An} {Object} {Oriented} {Model} for {Dialog} {Design}},
	volume = {87},
	booktitle = {Interact'87},
	publisher = {Elsevier},
	author = {Coutaz, Joëlle},
	year = {1987},
	pages = {431--436}
}

@inproceedings{calvary_single-user_1997,
	address = {New York, NY, USA},
	series = {{CHI} '97},
	title = {From {Single}-user {Architectural} {Design} to {PAC}*: {A} {Generic} {Software} {Architecture} {Model} for {CSCW}},
	isbn = {978-0-89791-802-2},
	shorttitle = {From {Single}-user {Architectural} {Design} to {PAC}*},
	optdoi = {10.1145/258549.258717},
	booktitle = {{ACM} {SIGCHI} {Conf}. on {Human} {Factors} in {Computing} {Systems}},
	publisher = {ACM},
	author = {Calvary, Gaëlle and Coutaz, Joëlle and Nigay, Laurence},
	year = {1997},
	keywords = {CSCW, PAC, agent, architectural style, interactive systems, interactor, software architecture modelling},
	pages = {242--249},
	file = {Calvary et al. - 1997 - From Single-user Architectural Design to PAC A G.pdf:/data/docs/refman/storage/SK9PIRG7/Calvary et al. - 1997 - From Single-user Architectural Design to PAC A G.pdf:application/pdf}
}



@book{liskov_program_2000,
	title = {Program development in {Java}: abstraction, specification, and object-oriented design},
	shorttitle = {Program development in {Java}},
	urldate = {2016-02-26},
	publisher = {Pearson Education},
	author = {Liskov, Barbara and Guttag, John},
	year = {2000},
	optfile = {Barbara Liskov - Program development in Java (English).pdf:/data/docs/refman/storage/ZM42XTJK/Barbara Liskov - Program development in Java (English).pdf:application/pdf;Snapshot:/data/docs/refman/storage/KWQDW3HA/books.html:text/html}
}

@article{booch_object-oriented_1986,
	title = {Object-{Oriented} {Development}},
	volume = {SE-12},
	issn = {0098-5589},
	doi = {10.1109/TSE.1986.6312937},
	abstract = {Object-oriented development is a partial-lifecycle software development method in which the decomposition of a system is based upon the concept of an object. This method is fundamentally different from traditional functional approaches to design and serves to help manage the complexity of massive software-intensive systems. The author examines the process of object-oriented development as well as the influences upon this approach from advances in abstraction mechanisms, programming languages, and hardware. The concept of an object is central to object-oriented development and so the properties of an object are discussed. The mapping of object-oriented techniques to Ada using a design case study is considered.},
	number = {2},
	journal = {IEEE Transactions on Software Engineering},
	author = {Booch, G.},
	month = feb,
	year = {1986},
	keywords = {Software Engineering, Object oriented modeling, Software, Ada, abstraction mechanisms, decomposition, hardware, object-oriented development, partial-lifecycle software development method, programming languages, software-intensive systems, Abstracts, Engines, Object recognition, Wheels, Abstract data type, object, software development method},
	pages = {211--221},
	file = {[PDF] from txstate.edu:/data/docs/refman/storage/NZGQ85EH/Booch - 1986 - Object-oriented development.pdf:application/pdf;IEEE Xplore Abstract Record:/data/docs/refman/storage/Q7JS3XAX/login.html:text/html}
}

@book{evans_domain-driven_2004,
	title = {Domain-Driven Design: {Tackling} {Complexity} in the {Heart} of {Software}},
	shorttitle = {Domain-driven design},
	publisher = {Addison-Wesley Professional},
	author = {Evans, Eric},
	year = {2004},
	optfile = {DDD-key-notes.txt:/data/docs/refman/storage/DWZ5NJFD/DDD-key-notes.txt:text/plain;Evans - 2004 - Domain-driven design tackling complexity in the h.pdf:/data/docs/refman/storage/BARGVIZ9/Evans - 2004 - Domain-driven design tackling complexity in the h.pdf:application/pdf;Snapshot:/data/docs/refman/storage/ZMKXNPKG/books.html:text/html}
}

@book{sommerville_software_2011,
	edition = {9th},
	title = {Software {Engineering}},
	isbn = {978-0-13-705346-9},
	abstract = {Intended for a sophomore/junior level course in software engineering.  The ninth edition of "Software Engineering" presents a broad perspective of software engineering, focusing on the processes and techniques fundamental to the creation of reliable, software systems. Increased coverage of agile methods and software reuse, along with coverage of 'traditional' plan-driven software engineering, gives readers the most up-to-date view of the field currently available. Practical case studies, a full set of easy-to-access supplements, and extensive web resources make teaching the course easier than ever.  The book is now structured into four parts:  1: Introduction to Software Engineering 2: Dependability and Security 3: Advanced Software Engineering 4: Software Engineering Management},
	language = {en},
	publisher = {Pearson},
	author = {Sommerville, Ian},
	year = {2011},
	keywords = {Computers / Software Development \& Engineering / General}
}

@inproceedings{pawson_naked_2002,
	address = {New York, NY, USA},
	title = {Naked {Objects}},
	isbn = {978-1-58113-626-5},
	optdoi ={10.1145/985072.985091},
	abstract = {Naked Objects is an open-source Java-based framework designed specifically to encourage the creation of business systems from behaviourally-complete business objects. In fact, with the Naked Objects framework you have no alternative but to make your business objects behaviourally-complete. The reason is that the framework exposes core business objects, such as Customer, Product and Order, directly to the user. All user actions consist of invoking methods directly upon those business objects, or sometimes upon the object's class. There are no scripts, no controllers, nor even any dialog boxes in between the user and the 'naked' objects.},
	booktitle = {{OOPSLA} '02},
	publisher = {ACM},
	author = {Pawson, Richard and Matthews, Robert},
	year = {2002},
	pages = {36--37},
	optfile = {Naked Objects - Pawson PhD.pdf:/data/docs/ref/seng/domain-driven-design/Naked Objects - Pawson PhD.pdf:application/pdf}
}

@book{paniza_learn_2011,
	address = {Paramount, CA},
	title = {Learn {OpenXava} by {Example}},
	isbn = {978-1-4663-6970-2},
	abstract = {The goal of this book is to teach you how to develop Java Enterprise applications with OpenXava and other Java related technologies, tools and frameworks. The way to achieve this goal is developing an application from scratch, step by step, until your application will be complete. In this book you'll learn, not only OpenXava, but JPA, Eclipse, PostgreSQL, JUnit, HtmlUnit, Hibernate Validator framework, Liferay, etc. And more important, you're going to learn techniques to solve common and advanced cases you'll face developing business applications.},
	publisher = {CreateSpace},
	author = {Paniza, Javier},
	year = {2011}
}


@article{dan_haywood_apache_2013,
	title = {Apache {Isis} - {Developing} {Domain}-driven {Java} {Apps}},
	volume = {21},
	issn = {1661-402X},
	language = {English},
	number = {2},
	journal = {Methods \& Tools: Practical knowledge source for software development professionals},
	author = {{Dan Haywood}},
	year = {2013},
	pages = {40--59}
}

@misc{apache-s.f_apache_2016,
	title = {Apache {Isis}},
	url = {http://isis.apache.org/},
	abstract = {Apache Isis™ is a framework for rapidly developing domain-driven apps in Java. Write your business logic in entities, domain services or view models, and the framework dynamically generates a representation of that domain model as a webapp or a RESTful API.},
	urldate = {2022-08-22},
	author = {{Apache-S.F}},
	year = {2022},
	optfile = {Apache Isis:/data/docs/refman/storage/WC9HA5AG/isis.apache.org.html:text/html}
}

@misc{noauthor_openxava_2016,
	title = {{OpenXava}},
	url = {http://openxava.org/},
	abstract = {OpenXava is an AJAX Java Framework for Rapid Development of Enterprise Web Applications.

In OpenXava you only have to write the domain classes in plain Java to get a web application ready for production.},
	urldate = {2022-08-22},
	year = {2022},
	optfile = {AJAX Java Web Framework for Rapid Application Development of Enterprise Applications - OpenXava:/data/docs/refman/storage/TWKPUWZB/openxava.org.html:text/html}
}

@article{damasevicius_taxonomy_2008,
	title = {Taxonomy of the {Fundamental} {Concepts} of {Metaprogramming}},
	volume = {37},
	copyright = {Copyright terms are indicated in the Republic of Lithuania Law on Copyright and Related Rights, Articles 4-37.},
	issn = {2335-884X},
	optdoi ={10.5755/j01.itc.37.2.11931},
	abstract = {Although widely used in software engineering, metaprogramming is often misunderstood. The researchers often disagree what concepts characterize metaprogramming. The concepts of metaprogramming are often used without acknowledging the usage of metaprogramming itself. We overview the examples and definitions of metaprogramming in computer science, identify, describe and discuss the fundamental concepts of metaprogramming (code generation, transformation, reflection, generalization, metaprogram, metadata, level of abstraction and separation of concerns). We analyze their relationship and present taxonomy, based on a study of sources on metaprogramming.},
	language = {en},
	number = {2},
	journal = {Information Technology And Control},
	author = {Damaševičius, Robertas and Štuikys, Vytautas},
	year = {2008},
	optfile = {meta-programming-taxonomy.pdf:/data/docs/ref/seng/meta-programming/meta-programming-taxonomy.pdf:application/pdf;Snapshot:/data/docs/refman/storage/A9JPW2A8/11931.html:text/html}
}

@inproceedings{le_domain-oriented_2015,
	title = {A {Domain}-{Oriented}, {Java} {Specification} {Language}},
	optdoi ={10.1109/KSE.2015.27},
	abstract = {In this paper, we propose a domain-oriented, Java specification language that uses executable Java's annotations to specify the state space of each domain class in the model (incl. Class, association, and domain constraint of each attribute.) We argue that, compared to the state-of-the-art, our language provides several benefits for both designer and programmer of Java programs. For designer, the language helps capture the state requirements more completely and more human-friendly using high level constraint functions, and these in turn help provide them with more relevant guidelines for identifying and defining the behavioural specification of class operations. For programmer, the language enables the generic design of two essential programming abstractions that are commonly used for checking the validity of the state space. Further, we will show how the domain class model specified by our language provides precise and executable mappings to a commonly-used logical data model. A prototype of the language has been implemented and is being used in various software projects.},
	booktitle = {Proc. 7th {Int}. {Conf}. {Knowledge} and {Systems} {Engineering} ({KSE})},
	publisher = {IEEE},
	author = {Le, Duc Minh},
	optmonth = oct,
	year = {2015},
	keywords = {Java, formal specification, specification languages, Java specification language, behavioural specification, domain class model, domain-oriented language, high level constraint function, logical data model, programming abstraction, Data models, Guidelines, Object oriented modeling, Software, Unified modeling language, design specification language, domain-oriented software design, object-oriented applications, software engineering design},
	pages = {25--30},
	optfile = {domain-oriented-java-specification-language-final.pdf:/home/dmle/projects/domainapp/docs/papers/3_specification/2015/jdomain-spec-lang/domain-oriented-java-specification-language-final.pdf:application/pdf}
}

@inproceedings{le_tree-based_2015,
	title = {A {Tree}-{Based}, {Domain}-{Oriented} {Software} {Architecture} for {Interactive} {Object}-{Oriented} {Applications}},
	optdoi ={10.1109/KSE.2015.26},
	abstract = {Model-View-Controller (MVC) is an established architectural design pattern for developing interactive, object-oriented applications. Numerous MVC-based application development approaches have been proposed in the literature, the more recent of which incorporate the domain-oriented design approach. From the architectural design view point, however, domain-oriented design has only been applied at the component level. It has not been used to model the architecture itself. In this paper, we propose a novel tree-based, domain-oriented architecture to fill this gap. Our architecture models an application as a set of modules, each of which is a structured class whose parts are of three M-V-C classes. The controller is a class template whose template parameter is bound to the domain class of the module. Complex modules are designed using containment tree that is defined directly on top of the domain class design model. The architecture has been implemented in a Java-based software framework which is being used in various software development projects.},
	booktitle = {Proc. 7th {Int}. {Conf}. {Knowledge} and {Systems} {Engineering} ({KSE})},
	publisher = {IEEE},
	author = {Le, Duc Minh},
	optmonth = oct,
	year = {2015},
	keywords = {Java, Object oriented modeling, Software, Unified modeling language, object-oriented applications, object-oriented methods, software management, Java-based software framework, MVC-based application develpment approach, domain class design model, domain-oriented design approach, interactive object-oriented application, model-view-controller, software development project, template parameter, tree-based domain-oriented software architecture, Computer architecture, Containers, User interfaces, Model-View-Controller (MVC) architecture, domain-oriented design, software architecture},
	pages = {19--24},
	optfile = {tree-based-domain-oriented-MVC-arch-final.pdf:/home/dmle/projects/domainapp/docs/papers/1_architecture/2015/ddarch/tree-based-domain-oriented-MVC-arch-final.pdf:application/pdf}
}

@book{hejlsberg_c_2010,
	address = {Upper Saddle River, NJ},
	edition = {4th},
	title = {The {C}\# {Programming} {Language}},
	isbn = {978-0-321-74176-9},
	abstract = {“Based on my own experience, I can safely say that every .NET developer who reads this will have at least one ‘aha’ moment and will be a better developer for it.”–From the Foreword by Don Box The popular C\# programming language combines the high productivity of rapid application development languages with the raw power of C and C++. Updated to cover the new features of C\# 4.0, including dynamic binding, named and optional parameters, and covariant and contravariant generic types, this release takes the language to the next level by adding the ability to cleanly write programs that don’t rely on static type definitions. This allows dynamic programming languages such as Python, Ruby, and JavaScript to feel native to C\#. The C\# Programming Language, Fourth Edition, continues to be the authoritative and annotated technical reference for C\# 4.0. Written by Anders Hejlsberg, the language’s architect, and his colleagues, Mads Torgersen, Scott Wiltamuth, and Peter Golde, this volume has been completely updated for C\# 4.0. The book provides the complete specification of the language, along with descriptions, reference materials, code samples, and annotations from twelve prominent C\# gurus. The many annotations bring a depth and breadth of understanding rarely found in any programming book. As the main text of the book introduces the concepts of the C\# language, cogent annotations explain why they are important, how they are used, how they relate to other languages, and even how they evolved. This book is the definitive, must-have reference for any developer who wants to understand C\#. With annotations from: Brad Abrams, Joseph Albahari, Krzysztof Cwalina, Jesse Liberty, Eric Lippert, Christian Nagel, Vladimir Reshetnikov, Marek Safar, Chris Sells, Peter Sestoft, Jon Skeet, and Bill Wagner.},
	language = {English},
	publisher = {Addison Wesley},
	author = {Hejlsberg, Anders and Torgersen, Mads and Wiltamuth, Scott and Golde, Peter},
	month = oct,
	year = {2010}
}

@inproceedings{le_domain-driven_2016,
	title = {Domain-{Driven} {Design} {Using} {Meta}-{Attributes}: {A} {DSL}-{Based} {Approach}},
	booktitle = {Proc. 8th {Int}. {Conf}. {Knowledge} and {Systems} {Engineering} ({KSE})},
	publisher = {IEEE},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	optmonth = oct,
	year = {2016},
	keywords = {Java, formal specification, specification languages, Java specification language, behavioural specification, domain class model, domain-oriented language, high level constraint function, logical data model, programming abstraction, Data models, Guidelines, Object oriented modeling, Software, Unified modeling language, design specification language, domain-oriented software design, object-oriented applications, software engineering design},
	pages = {67--72},
	optfile = {Le et al. - 2016 - Domain-Driven Design Using Meta-Attributes A DSL-.pdf:/data/docs/refman/storage/AJSFA3T4/Le et al. - 2016 - Domain-Driven Design Using Meta-Attributes A DSL-.pdf:application/pdf}
}

@inproceedings{le_domain-driven_2016-1,
	title = {Domain-{Driven} {Design} {Patterns}: {A} {Metadata}-{Based} {Approach}},
	booktitle = {Proc. 12th {Int}. {Conf}. on {Computing} and {Communication} {Technologies} ({RIVF})},
	publisher = {IEEE},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	optmonth = nov,
	year = {2016},
	keywords = {Java, formal specification, specification languages, Java specification language, behavioural specification, domain class model, domain-oriented language, high level constraint function, logical data model, programming abstraction, Data models, Guidelines, Object oriented modeling, Software, Unified modeling language, design specification language, domain-oriented software design, object-oriented applications, software engineering design},
	pages = {247--252},
	optfile = {Le et al. - 2016 - Domain-Driven Design Patterns A Metadata-Based Ap.pdf:/data/docs/refman/storage/24FQRTCA/Le et al. - 2016 - Domain-Driven Design Patterns A Metadata-Based Ap.pdf:application/pdf}
}

@inproceedings{le_generative_2017,
	title = {Generative {Software} {Module} {Development}: {A} {Domain}-{Driven} {Design} {Perspective}},
	shorttitle = {Generative software module development},
	optdoi ={10.1109/KSE.2017.8119438},
	abstract = {Object-oriented domain-driven design (DDD) aims to develop software (iteratively) around a realistic model of the application domain, which both thoroughly captures the domain requirements and is technically feasible for implementation. The main focus of existing work in DDD has been on using an annotation-based extension of object-oriented programming language to build the domain model. However, these work do not consider software modules as first-class objects and thus lack a method for their development. In this paper, we propose a generative software module development method to bridge this gap. More specifically, we make the following contributions: (1) An annotation-based internal DSL named MCCL for configuring the modules. This language uses a reflective module configuration class design. (2) A module configuration class generator that generates a module configuration class from a domain class. (3) Update the module configuration class of a module when this module's structure is changed. (4) Demonstrate MCCL using a Java software tool.},
	booktitle = {Proc. 9th {Int}. {Conf}. on {Knowledge} and {Systems} {Engineering} ({KSE})},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	optmonth = oct,
	year = {2017},
	keywords = {DSL, Java, Object oriented modeling, Software, Unified modeling language, Generators, Software engineering},
	pages = {77--82},
	optfile = {IEEE Xplore Abstract Record:/data/docs/refman/storage/UREWZ9FY/8119438.html:text/html;Le et al. - 2017 - Generative software module development A domain-d.pdf:/data/docs/refman/storage/QVEU48CR/Le et al. - 2017 - Generative software module development A domain-d.pdf:application/pdf}
}

@article{le_generative_2018,
	title = {Generative {Software} {Module} {Development} for {Domain}-{Driven} {Design} with {Annotation}-{Based} {Domain} {Specific} {Language}},
	volume = {120},
	issn = {0950-5849},
	doi = {10.1016/j.infsof.2019.106239},
	abstract = {Context: Object-oriented domain-driven design (DDD) aims to iteratively develop software around a realistic model of the application domain, which both thoroughly captures the domain requirements and is technically feasible for implementation. The main focus of recent work in DDD has been on using a form of annotation-based domain specific language (aDSL), internal to an object-oriented programming language, to build the domain model. However, these work do not consider software modules as first-class objects and thus lack a method for their development. Objective: In this paper, we tackle software module development with the DDD method by adopting a generative approach that uses aDSL. To achieve this, we first extend a previous work on module-based software architecture with three enhancements that make it amenable to generative development. We then treat module configurations as first-class objects and define an aDSL, named MCCL, to express module configuration classes. To improve productivity, we define function MCCGen to automatically generate each configuration class from the module’s domain class. Method:We define our method as a refinement of an aDSL-based software development method from a previous work. We apply meta-modelling with UML/OCL to define MCCL and implement MCCL in a Java software framework. We evaluate the applicability of our method using a case study and formally define an evaluation framework for module generativity. We also analyse the correctness and performance of function MCCGen. Results:MCCL is an aDSL for module configurations. Our evaluation shows MCCL is applicable to complex problem domains. Further, the MCCs and software modules can be generated with a high and quantifiable degree of automation. Conclusion:Our method bridges an important gap in DDD with a software module development method that uses a novel aDSL with a module-based software architecture and a generative technique for module configuration.},
	language = {en},
	journal = {Information and Software Technology},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	month = apr,
	year = {2020},
	keywords = {Attribute-oriented Programming (AtOP), Domain-driven design (DDD), Domain-specific language (DSL), Object-oriented programming language (OOPL), UML-based domain modelling, Module-based architecture},
	pages = {106--239},
	file = {Le et al. - 2020 - Generative Software Module Development for Domain-.pdf:/data/docs/refman/storage/LNQGLFCL/Le et al. - 2020 - Generative Software Module Development for Domain-.pdf:application/pdf;ScienceDirect Snapshot:/data/docs/refman/storage/C5HQH8EC/S0950584919302563.html:text/html},
}



@phdthesis{le_unified_2019,
	address = {Hanoi},
	type = {{PhD} {Thesis}},
	title = {A {Unified} {View} {Approach} to {Software} {Development} {Automation}},
	language = {en},
	school = {VNU University of Engineering and Technology, Vietnam National University (Hanoi)},
	author = {Le, Duc Minh},
	year = {2019},
	file = {Le - 2019 - A Unified View Approach to Software Development Au.pdf:/data/docs/refman/storage/FKX7Q3B9/Le - 2019 - A Unified View Approach to Software Development Au.pdf:application/pdf},
}

@book{kleppe_software_2008,
	address = {Upper Saddle River, NJ},
	edition = {1st},
	title = {Software {Language} {Engineering}: {Creating} {Domain}-{Specific} {Languages} {Using} {Metamodels}},
	isbn = {978-0-321-55345-4},
	shorttitle = {Software {Language} {Engineering}},
	abstract = {Software practitioners are rapidly discovering the immense value of Domain-Specific Languages (DSLs) in solving problems within clearly definable problem domains. Developers are applying DSLs to improve productivity and quality in a wide range of areas, such as finance, combat simulation, macro scripting, image generation, and more. But until now, there have been few practical resources that explain how DSLs work and how to construct them for optimal use.        Software Language Engineering  fills that need. Written by expert DSL consultant Anneke Kleppe, this is the first comprehensive guide to successful DSL design. Kleppe systematically introduces and explains every ingredient of an effective  language specification, including its description of concepts, how those concepts are denoted, and what those concepts mean in relation to the problem domain. Kleppe carefully illuminates good design strategy, showing how to maximize the flexibility of the languages you create. She also demonstrates powerful techniques for creating new DSLs that cooperate well with general-purpose languages and leverage their power.     Completely tool-independent, this book can serve as the primary resource for readers using Microsoft DSL tools, the Eclipse Modeling Framework, openArchitectureWare, or any other DSL toolset. It contains multiple examples, an illustrative running case study, and insights and background information drawn from Kleppe’s leading-edge work as a DSL researcher.     Specific topics covered include         Discovering the types of problems that DSLs can solve, and when to use them     Comparing DSLs with general-purpose languages, frameworks, APIs, and other approaches     Understanding the roles and tools available to language users and engineers     Creating each component of a DSL specification     Modeling both concrete and abstract syntax     Understanding and describing language semantics     Defining textual and visual languages based on object-oriented metamodeling and graph transformations     Using metamodels and associated tools to generate grammars     Integrating object-oriented modeling with graph theory     Building code generators for new languages     Supporting multilanguage models and programs       This book provides software engineers with all the guidance they need to create DSLs that solve real problems more rapidly, and with higher-quality code.},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Kleppe, Anneke},
	month = dec,
	year = {2008}
}

@inproceedings{kohler_integrating_2000,
	address = {New York, NY, USA},
	series = {{ICSE} '00},
	title = {Integrating {UML} {Diagrams} for {Production} {Control} {Systems}},
	isbn = {978-1-58113-206-9},
	doi = {10.1145/337180.337207},
	abstract = {This paper proposes to use SDL block diagrams, UML class diagrams, and UML behavior diagrams like collaboration diagrams, activity diagrams, and statecharts as a visual programming language. We describe a modeling approach for flexible, autonomous production agents, which are used for the decentralization of production control systems. In order to generate a (Java) implementation of a production control system from its specification, we define a precise semantics for the diagrams and we define how different (kinds of) diagrams are combined to a complete executable specification.Generally, generating code from UML behavior diagrams is not well understood. Frequently, the semantics of a UML behavior diagram depends on the topic and the aspect that is modeled and on the designer that created it. In addition, UML behavior diagrams usually model only example scenarios and do not describe all possible cases and possible exceptions.We overcome these problems by restricting the UML notation to a subset of the language that has a precise semantics. In addition, we define which kind of diagram should be used for which purpose and how the different kinds of diagrams are integrated to a consistent overall view.},
	booktitle = {Proc.  22nd {Int}. {Conf}. on {Software} {Engineering}},
	publisher = {ACM},
	author = {Köhler, Hans J. and Nickel, Ulrich and Niere, Jörg and Zündorf, Albert},
	year = {2000},
	keywords = {UML, SDL, embedded systems, collaboration diagrams, graph grammars, statecharts},
	pages = {241--251},
	file = {Köhler et al. - 2000 - Integrating UML Diagrams for Production Control Sy.pdf:/data/docs/refman/storage/GDGENWU7/Köhler et al. - 2000 - Integrating UML Diagrams for Production Control Sy.pdf:application/pdf}
}

@article{selonen_transformations_2003,
	title = {Transformations {Between} {UML} {Diagrams}},
	volume = {14},
	copyright = {Access limited to members},
	issn = {1063-8016 DOI: 10.4018/jdm.2003070103},
	doi = {10.4018/jdm.2003070103},
	abstract = {Transformations Between UML Diagrams: 10.4018/jdm.2003070103: The Unified Modeling Language (UML) provides various diagram types for describing a system from different perspectives or abstraction levels. Hence, UML},
	language = {en},
	number = {3},
	journal = {JDM},
	author = {Selonen, Petri and Koskimies, Kai and Sakkinen, Markku},
	month = jul,
	year = {2003},
	pages = {37--55},
	file = {Selonen et al. - 2003 - Transformations Between UML Diagrams.pdf:/data/docs/refman/storage/WQXPR4PF/Selonen et al. - 2003 - Transformations Between UML Diagrams.pdf:application/pdf;Snapshot:/data/docs/refman/storage/EVEAQRC9/3298.html:text/html}
}

@article{niaz_object-oriented_2005,
	title = {An {Object}-{Oriented} {Approach} to {Generate} {Java} {Code} from {UML} {Statecharts}},
	volume = {6},
	number = {2},
	journal = {International Journal of Computer \& Information Science},
	author = {Niaz, Iftikhar Azim and Tanaka, Jiro},
	year = {2005},
	pages = {83--98},
	file = {Niaz and Tanaka - 2005 - An Object-Oriented Approach to Generate Java Code .pdf:/data/docs/refman/storage/JQLIJASL/Niaz and Tanaka - 2005 - An Object-Oriented Approach to Generate Java Code .pdf:application/pdf}
}

@misc{omg_unified_2015,
	title = {Unified {Modeling} {Language} version 2.5},
	author = {{OMG}},
	year = {2015},
	optfile = {Activity-actions-summary.odt:/data/docs/refman/storage/I5C8ITMU/Activity-actions-summary.odt:application/vnd.oasis.opendocument.text;Activity-summary.odt:/data/docs/refman/storage/P2PKX7DA/Activity-summary.odt:application/vnd.oasis.opendocument.text;UML 2.5:/data/docs/refman/storage/T67UMMTR/2.html:text/html;UML-spec-v2.5.pdf:/data/docs/refman/storage/VZV4CGX7/UML-spec-v2.5.pdf:application/pdf}
}

@book{gosling_java_2014,
	address = {Upper Saddle River, NJ},
	edition = {1st},
	title = {The {Java} {Language} {Specification}, {Java} {SE} 8 {Edition}},
	isbn = {978-0-13-390069-9},
	abstract = {Written by the inventors of the technology, The Java® Language Specification, Java SE 8 Edition is the definitive technical reference for the Java programming language.   The book provides complete, accurate, and detailed coverage of the Java programming language. It fully describes the new features added in Java SE 8, including lambda expressions, method references, default methods, type annotations, and repeating annotations. The book also includes many explanatory notes and carefully distinguishes the formal rules of the language from the practical behavior of compilers.},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Gosling, James and Joy, Bill and Jr, Guy L. Steele and Bracha, Gilad and Buckley, Alex},
	month = may,
	year = {2014},
	optfile = {java-language-specification-J2SE8.pdf:/data/docs/refman/storage/73PK79MM/java-language-specification-J2SE8.pdf:application/pdf}
}

@book{aho_foundations_1994,
	address = {New York},
	edition = {2nd},
	title = {Foundations of {Computer} {Science}: {C} {Edition}},
	isbn = {978-0-7167-8284-1},
	shorttitle = {Foundations of {Computer} {Science}},
	abstract = {This text combines the theoretical foundations of computing with essential discrete mathematics. It follows the same organization as its predecessor, Foundations of Computer Science (also published by W.H. Freeman), with all examples and exercises in C.},
	language = {English},
	publisher = {W. H. Freeman},
	author = {Aho, Alfred V. and Ullman, Jeffrey D.},
	month = oct,
	year = {1994},
	optfile = {focs.html:/data/docs/ref/courses/cs/fundamentals_cs/infolab.stanford.edu/~ullman/focs.html:text/html}
}

@article{mernik_when_2005,
	title = {When and {How} to {Develop} {Domain}-specific {Languages}},
	volume = {37},
	issn = {0360-0300},
	doi ={10.1145/1118890.1118892},
	abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
	number = {4},
	journal = {ACM Comput. Surv.},
	author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
	month = dec,
	year = {2005},
	keywords = {Domain-specific language, application language, domain analysis, language development system},
	pages = {316--344},
	optfile = {when and how to develop dsls.pdf:/data/docs/refman/storage/QI4XKESJ/when and how to develop dsls.pdf:application/pdf}
}

@book{vernon_implementing_2013,
	address = {Upper Saddle River, NJ},
	edition = {1st},
	title = {Implementing {Domain}-{Driven} {Design}},
	isbn = {978-0-321-83457-7},
	abstract = {“For software developers of all experience levels looking to improve their results, and design and implement domain-driven enterprise applications consistently with the best current state of professional practice,  Implementing Domain-Driven Design  will impart a treasure trove of knowledge hard won within the DDD and enterprise application architecture communities over the last couple decades.” –Randy Stafford, Architect At-Large, Oracle Coherence Product Development   “This book is a must-read for anybody looking to put DDD into practice.” –Udi Dahan, Founder of NServiceBus       Implementing Domain-Driven Design  presents a top-down approach to understanding domain-driven design (DDD) in a way that fluently connects strategic patterns to fundamental tactical programming tools. Vaughn Vernon couples guided approaches to implementation with modern architectures, highlighting the importance and value of focusing on the business domain while balancing technical considerations.   Building on Eric Evans’ seminal book, Domain-Driven Design, the author presents practical DDD techniques through examples from familiar domains. Each principle is backed up by realistic Java examples–all applicable to C\# developers–and all content is tied together by a single case study: the delivery of a large-scale Scrum-based SaaS system for a multitenant environment.   The author takes you far beyond “DDD-lite” approaches that embrace DDD solely as a technical toolset, and shows you how to fully leverage DDD’s “strategic design patterns” using Bounded Context, Context Maps, and the Ubiquitous Language. Using these techniques and examples, you can reduce time to market and improve quality, as you build software that is more flexible, more scalable, and more tightly aligned to business goals.   Coverage includes  Getting started the right way with DDD, so you can rapidly gain value from it Using DDD within diverse architectures, including Hexagonal, SOA, REST, CQRS, Event-Driven, and Fabric/Grid-Based Appropriately designing and applying Entities–and learning when to use Value Objects instead Mastering DDD’s powerful new Domain Events technique Designing Repositories for ORM, NoSQL, and other databases},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Vernon, Vaughn},
	month = feb,
	year = {2013}
}

@book{fowler_domain-specific_2010,
	title = {Domain-{Specific} {Languages}},
	isbn = {978-0-13-210754-9},
	abstract = {When carefully selected and used, Domain-Specific Languages (DSLs) may simplify complex code, promote effective communication with customers, improve productivity, and unclog development bottlenecks. In Domain-Specific Languages, noted software development expert Martin Fowler first provides the information software professionals need to decide if and when to utilize DSLs. Then, where DSLs prove suitable, Fowler presents effective techniques for building them, and guides software engineers in choosing the right approaches for their applications.This book’s techniques may be utilized with most modern object-oriented languages; the author provides numerous examples in Java and C\#, as well as selected examples in Ruby. Wherever possible, chapters are organized to be self-standing, and most reference topics are presented in a familiar patterns format.Armed with this wide-ranging book, developers will have the knowledge they need to make important decisions about DSLs—and, where appropriate, gain the significant technical and business benefits they offer.The topics covered include:• How DSLs compare to frameworks and libraries, and when those alternatives are sufficient• Using parsers and parser generators, and parsing external DSLs• Understanding, comparing, and choosing DSL language constructs• Determining whether to use code generation, and comparing code generation strategies• Previewing new language workbench tools for creating DSLs},
	language = {en},
	urldate = {2016-12-04},
	publisher = {Addison-Wesley Professional},
	author = {Fowler, Martin and White, Terry},
	month = sep,
	year = {2010},
	optfile = {Domain Specific Languages-MartinFowler2010-notes.odt:/data/docs/refman/storage/23GUHR8M/Domain Specific Languages-MartinFowler2010-notes.odt:application/vnd.oasis.opendocument.text;Domain Specific Languages-MartinFowler2010.pdf:/data/docs/refman/storage/28UZ9W6F/Domain Specific Languages-MartinFowler2010.pdf:application/pdf}
}

@incollection{cabot_object_2012,
	series = {{LNCS}},
	title = {Object {Constraint} {Language} ({OCL}): {A} {Definitive} {Guide}},
	copyright = {©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-30981-6 978-3-642-30982-3},
	shorttitle = {Object {Constraint} {Language} ({OCL})},
	abstract = {The Object Constraint Language (OCL) started as a complement of the UML notation with the goal to overcome the limitations of UML (and in general, any graphical notation) in terms of precisely specifying detailed aspects of a system design. Since then, OCL has become a key component of any model-driven engineering (MDE) technique as the default language for expressing all kinds of (meta)model query, manipulation and specification requirements. Among many other applications, OCL is frequently used to express model transformations (as part of the source and target patterns of transformation rules), well-formedness rules (as part of the definition of new domain-specific languages), or code-generation templates (as a way to express the generation patterns and rules). This chapter pretends to provide a comprehensive view of this language, its many applications and available tool support as well as the latest research developments and open challenges around it.},
	language = {en},
	number = {7320},
	booktitle = {Formal {Methods} for {Model}-{Driven} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Cabot, Jordi and Gogolla, Martin},
	editor = {Bernardo, Marco and Cortellessa, Vittorio and Pierantonio, Alfonso},
	year = {2012},
	optdoi ={10.1007/978-3-642-30982-3_3},
	keywords = {Programming Languages, Compilers, Interpreters, Software Engineering, Mathematical Logic and Formal Languages, Management of Computing and Information Systems, Software Engineering/Programming and Operating Systems, Information Systems Applications (incl. Internet)},
	pages = {58--90},
	optfile = {Object constraint language - definitive guide.pdf:/data/docs/refman/storage/QXJR7E5G/Object constraint language - definitive guide.pdf:application/pdf;Snapshot:/data/docs/refman/storage/DQU8FMXC/978-3-642-30982-3_3.html:text/html}
}

@incollection{visser_webdsl:_2008,
	series = {{LNCS}},
	title = {{WebDSL}: {A} {Case} {Study} in {Domain}-{Specific} {Language} {Engineering}},
	copyright = {©2008 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-88642-6 978-3-540-88643-3},
	shorttitle = {{WebDSL}},
	abstract = {The goal of domain-specific languages (DSLs) is to increase the productivity of software engineers by abstracting from low-level boilerplate code. Introduction of DSLs in the software development process requires a smooth workflow for the production of DSLs themselves. This requires technology for designing and implementing DSLs, but also a methodology for using that technology. That is, a collection of guidelines, design patterns, and reusable DSL components that show developers how to tackle common language design and implementation issues. This paper presents a case study in domain-specific language engineering. It reports on a project in which the author designed and built WebDSL, a DSL for web applications with a rich data model, using several DSLs for DSL engineering: SDF for syntax definition and Stratego/XT for code generation. The paper follows the stages in the development of the DSL. The contributions of the paper are three-fold. (1) A tutorial in the application of the specific SDF and Stratego/XT technology for building DSLs. (2) A description of an incremental DSL development process. (3) A domain-specific language for web-applications with rich data models. The paper concludes with a survey of related approaches.},
	language = {en},
	number = {5235},
	booktitle = {Generative and {Transformational} {Techniques} in {Software} {Engineering} ({GTTSE}) {II}},
	publisher = {Springer Berlin Heidelberg},
	author = {Visser, Eelco},
	opteditor = {Lämmel, Ralf and Visser, Joost and Saraiva, João},
	year = {2008},
	optdoi ={10.1007/978-3-540-88643-3_7},
	keywords = {Software Engineering, Software Engineering/Programming and Operating Systems, Programming Techniques, Computation by Abstract Devices, Computer Communication Networks, Control Structures and Microprogramming},
	pages = {291--373},
	optfile = {Snapshot:/data/docs/refman/storage/8VK67HAN/978-3-540-88643-3_7.html:text/html;Visser - 2008 - WebDSL A Case Study in Domain-Specific Language E.pdf:/data/docs/refman/storage/MZJRAWVH/Visser - 2008 - WebDSL A Case Study in Domain-Specific Language E.pdf:application/pdf}
}

@techreport{le_domain_2017,
	title = {On {Domain} {Driven} {Design} {Using} {Annotation}-{Based} {Domain} {Specific} {Language} [{Extended}]},
	institution = {VNU University of Engineering and Technology},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	year = {2017},
	optfile = {DCSL-formal-extended.pdf:/home/dmle/projects/domainapp/docs/reports/8_dcsl-and-behavioural-modelling/extended-version/DCSL-formal-extended.pdf:application/pdf}
}

@inproceedings{le_jdomainapp_2017,
  address = {New York, USA},
	title = {{jDomainApp}: {A} {Module}-{Based} {Domain}-{Driven} {Software} {Framework}},
	shorttitle = {{jDomainApp}: {A} {Module}-based {Domain}-{Driven} {Software} {Framework}},
	optdoi = {https://doi.org/10.1145/3368926.3369657},
	abstract = {Object-oriented domain-driven design (DDD) has been advocated to be the most common form of DDD, thanks to the popularity of object-oriented development methodologies and languages. Although the DDD method prescribes a set of design patterns for the domain model, it provides no languages or tools that realise these patterns. There have been several software frameworks developed to address this gap. However, these frameworks have not tackled two important software construction issues: generative, module-based software construction and development environ ment integration. In this paper, we propose a framework, named jDomainApp, and an Eclipse IDE plugin to address these issues. In particular, we extend our recent works on DDD to propose a software configuration language that expresses the software configuration, needed to automatically generate software from a set of modules. The modules are automatically generated using a module configuration language that we defined in a previous work. We demonstrate the framework and plug-in using a real-world software example. Further, we evaluate the performance of software construction to show that it is scalable to handle large software.},
	booktitle = {Proc. 10th {Int}. {Symp}. on {Information} and {Communication} {Technology} ({SOICT})},
	publisher = {ACM},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Vu, Ha Thanh},
	year = {2019},
	keywords = {DSL, Java, Object oriented modeling, Software, Unified modeling language, Generators, Software engineering},
	pages = {399--406},
	file = {front.pdf:/data/docs/refman/storage/HMY98HF5/front.pdf:application/pdf;Le et al. - 2019 - jDomainApp A Module-Based Domain-Driven Software .pdf:/data/docs/refman/storage/4LWMY7XN/Le et al. - 2019 - jDomainApp A Module-Based Domain-Driven Software .pdf:application/pdf},
}

@article{le_domain_2018,
	title = {On {Domain} {Driven} {Design} {Using} {Annotation}-{Based} {Domain} {Specific} {Language}},
	volume = {54},
	issn = {1477-8424},
	doi = {10.1016/j.cl.2018.05.001},
	abstract = {The aim of object-oriented domain-driven design (DDD) is to iteratively develop software around a realistic domain model. Recent work in DDD use an annotation-based extension of object-oriented programming language to build the domain model. This model becomes the basis for a ubiquitous language and is used as input to generate software. However, the annotation-based extensions of these work do not adequately address the primitive and essential structural and behavioural modelling requirements of practical software. Further, they do not precisely characterise the software that is generated from the domain model. In this paper, we propose a DSL-based DDD method to address these limitations. We make four contributions: (1) An annotation-based domain-specific language (DSL) named DCSL, whose annotation extension expresses a set of essential structural constraints and the essential behaviour of a domain class. (2) A structural mapping between the state and behaviour spaces of a domain class. This mapping enables a technique for generating the behavioural specification. (3) A technique that uses DCSL to support behavioural modelling with UML activity diagram. (4) A 4-property characterisation of the software generated from the domain model. We demonstrate our method with a Java software tool and evaluate DCSL in the context of DDD.},
	journal = {Computer Languages, Systems \& Structures},
	author = {Le, Duc Minh and Dang, Duc-Hanh and Nguyen, Viet-Ha},
	year = {2018},
	keywords = {Attribute-oriented Programming (AtOP), Domain-driven design (DDD), Domain-specific language (DSL), Object-oriented programming language (OOPL), UML-based domain modelling},
	pages = {199--235},
	file = {Le et al. - 2018 - On Domain Driven Design Using Annotation-Based Dom.pdf:/data/docs/refman/storage/3TIYRRWW/Le et al. - 2018 - On Domain Driven Design Using Annotation-Based Dom.pdf:application/pdf;ScienceDirect Snapshot:/data/docs/refman/storage/JAYIY5ZT/S147784241730204X.html:text/html},
}

@misc{omg_object_2014,
	title = {Object {Constraint} {Language} {Version} 2.4},
	author = {{OMG}},
	year = {2014},
	optfile = {OCL 2.4:/data/docs/refman/storage/64P9AP2A/2.html:text/html;OMG - 2014 - OCL 2.4.pdf:/data/docs/refman/storage/TG7FB4TB/OMG - 2014 - OCL 2.4.pdf:application/pdf}
}

@article{paige_tutorial_2014,
	series = {Selected {Papers} from the {5th} {Int.} {Conf.} on {Software} {Language} {Engineering} ({SLE} 2012)},
	title = {A tutorial on metamodelling for grammar researchers},
	volume = {96},
	issn = {0167-6423},
	doi ={10.1016/j.scico.2014.05.007},
	abstract = {A metamodel has been defined as: a model of a model; a definition of a language; a description of abstract syntax; and a description of a domain. Because of these varied definitions, it is difficult to explain why metamodels are constructed, what can be done with them, and how they are built. This tutorial introduces the key concepts, terminology and philosophy behind metamodelling, focusing on its use for language engineering, and expressed in a way that is intended to be accessible to researchers who may be more familiar with the use of traditional context-free grammar techniques. We highlight the main differences between metamodelling and grammar-based approaches, describe how to map metamodelling concepts and techniques to grammar concepts and techniques, and highlight some of the strengths and weaknesses of metamodelling via a set of small, but realistic examples.},
	journal = {Science of Computer Programming},
	author = {Paige, Richard F. and Kolovos, Dimitrios S. and Polack, Fiona A. C.},
	month = dec,
	year = {2014},
	keywords = {grammars, Metamodelling, Models, Bridges, Unification},
	pages = {396--416},
	optfile = {Paige et al. - 2014 - A tutorial on metamodelling for grammar researcher.pdf:/data/docs/refman/storage/W2MN8HCU/Paige et al. - 2014 - A tutorial on metamodelling for grammar researcher.pdf:application/pdf;ScienceDirect Snapshot:/data/docs/refman/storage/RREAJ5TU/S0167642314002457.html:text/html}
}

@book{meyer_object-oriented_1997,
	address = {Santa Barbara (California)},
	edition = {2nd},
	title = {Object-{Oriented} {Software} {Construction}},
	publisher = {ISE Inc.},
	author = {Meyer, Bertrand},
	year = {1997},
	optfile = {Object-Oriented_Software_Construction_SE.pdf:/data/docs/refman/storage/YX7BPYDB/Object-Oriented_Software_Construction_SE.pdf:application/pdf}
}


@book{liskov_abstraction_1986,
	title = {Abstraction and specification in program development},
	publisher = {MIT Press},
	author = {Liskov, Barbara and Guttag, John},
	year = {1986},
	optfile = {Liskov and Guttag - 1986 - Abstraction and specification in program developme.pdf:/data/docs/refman/storage/8JNHAPH7/Liskov and Guttag - 1986 - Abstraction and specification in program developme.pdf:application/pdf}
}

@article{nosal_language_2016,
	title = {Language {Composition} {Using} {Source} {Code} {Annotations}},
	volume = {13},
	abstract = {In this paper we examine source code annotations from the viewpoint of formal languages - we discuss their abstract syntax, concrete syntax, and semantics, thus showing the correspondence between annotations and formal languages. We propose to consider a set of all annotations and their parameters processed by the same reference implementation (they belong to the same domain) to be called an annotation-based language. The performed analysis also pinpoints a specificity of annotations in comparison with formal languages in general - the binding between annotations and a host language. We elaborate this idea with an analysis of annotations’ potential for language composition, in particular for pure embedding. We then show how pure embedding with annotations can be used for language unification, language referencing by extension, and language extension. This work provides a basis for further research in the field of source code annotations in the context of formal languages.},
	number = {3},
	journal = {Computer Science and Information Systems},
	author = {Nosál’, Milan and Sulír, Matúš and Juhár, Ján},
	year = {2016},
	pages = {707--729},
	optfile = {Nosál’ et al. - 2016 - Language composition using source code annotations.pdf:/data/docs/refman/storage/3JVTLZ8I/Nosál’ et al. - 2016 - Language composition using source code annotations.pdf:application/pdf;Snapshot:/data/docs/refman/storage/6MGDIR9M/Article.html:text/html}
}

@inproceedings{hudak_modular_1998,
	title = {Modular domain specific languages and tools},
	optdoi ={10.1109/ICSR.1998.685738},
	abstract = {A domain specific language (DSL) allows one to develop software for a particular application domain quickly and effectively, yielding programs that are easy to understand, reason about, and maintain. On the other hand, there may be a significant overhead in creating the infrastructure needed to support a DSL. To solve this problem, a methodology is described for building domain specific embedded languages (DSELs), in which a DSL is designed within an existing, higher-order and typed, programming language such as Haskell or ML. In addition, techniques are described for building modular interpreters and tools for DSELs. The resulting methodology facilitates reuse of syntax semantics, implementation code, software tools, as well as look-and-feel},
	booktitle = {Proc. 5th {Int}. {Conf}. on {Software} {Reuse}},
	author = {Hudak, P.},
	month = jun,
	year = {1998},
	keywords = {DSL, Computer languages, Application software, Computer science, Costs, Domain specific languages, Buildings, domain specific embedded languages, functional languages, Hardware, Haskell, higher-order typed programming language, implementation code, methodology, ML, modular domain specific languages, modular interpreters, program interpreters, program understanding, Programming, semantics, software maintenance, Software maintenance, software reusability, software reuse, software tools, syntax},
	pages = {134--142},
	optfile = {Hudak - 1998 - Modular domain specific languages and tools.pdf:/data/docs/refman/storage/Y4RCFVG7/Hudak - 1998 - Modular domain specific languages and tools.pdf:application/pdf;IEEE Xplore Abstract Record:/data/docs/refman/storage/F84WZHR4/685738.html:text/html}
}

@book{gosling_java_2017,
	address = {California, USA},
	title = {The {Java} {Language} {Specification}: {Java} {SE} 9 {Edition}},
	language = {English},
	publisher = {Oracle America, Inc.},
	author = {Gosling, James and Joy, Bill and Jr, Guy L. Steele and Bracha, Gilad and Buckley, Alex and Smith, Daniel},
	month = aug,
	year = {2017},
	optfile = {Gosling et al. - 2017 - The Java Language Specification Java SE 9 Edition.pdf:/data/docs/refman/storage/KL5F5DSP/Gosling et al. - 2017 - The Java Language Specification Java SE 9 Edition.pdf:application/pdf}
}

@book{gosling_java_2018,
	address = {California, USA},
	title = {The {Java} {Language} {Specification}: {Java} {SE} 10 {Edition}},
	language = {English},
	publisher = {Oracle America, Inc.},
	author = {Gosling, James and Joy, Bill and Jr, Guy L. Steele and Bracha, Gilad and Buckley, Alex and Smith, Daniel},
	month = feb,
	year = {2018},
	optfile = {Gosling et al. - 2018 - The Java Language Specification Java SE 10 Editio.pdf:/data/docs/refman/storage/X5N9KJWS/Gosling et al. - 2018 - The Java Language Specification Java SE 10 Editio.pdf:application/pdf}
}

@misc{oracle_java_2018,
	title = {Java {Platform}, {Standard} {Edition} {Java} {Language} {Updates}},
	copyright = {Copyright © 2017, 2018, Oracle and/or its affiliates. All rights reserved.},
	optUrl = {https://docs.oracle.com/javase/10/language/toc.htm#JSLAN-GUID-B06D7006-D9F4-42F8-AD21-BF861747EDCF},
	language = {en-US},
	urldate = {2018-03-24},
	author = {{Oracle}},
	year = {2018},
	optfile = {Oracle - 2018 - Java Platform, Standard Edition Java Language Upda.pdf:/data/docs/refman/storage/3ULNDMU8/Oracle - 2018 - Java Platform, Standard Edition Java Language Upda.pdf:application/pdf;Snapshot:/data/docs/refman/storage/5SMAHZ9B/toc.html:text/html}
}

@misc{oracle_java_2017,
	title = {Java {Platform}, {Standard} {Edition} {What}’s {New} in {Oracle} {JDK} 9},
	copyright = {Copyright © 2017, Oracle and/or its affiliates. All rights reserved.},
	optUrl = {https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6},
	language = {en-US},
	urldate = {2018-03-24},
	author = {{Oracle}},
	year = {2017},
	optfile = {Oracle - 2017 - Java Platform, Standard Edition What’s New in Orac.pdf:/data/docs/refman/storage/7UV4NE3L/Oracle - 2017 - Java Platform, Standard Edition What’s New in Orac.pdf:application/pdf;Snapshot:/data/docs/refman/storage/KGEW3PTT/toc.html:text/html}
}

@misc{paul_deitel_understanding_2017,
	title = {Understanding {Java} 9 {Modules}},
	optUrl = {https://www.oracle.com/corporate/features/understanding-java-9-modules.html},
	abstract = {What they are and how to use them.},
	language = {en-US},
	urldate = {2018-03-25},
	author = {{Paul Deitel}},
	year = {2017},
	optfile = {Snapshot:/data/docs/refman/storage/CCQFZ44U/understanding-java-9-modules.html:text/html}
}

@article{riehle_understanding_1996,
	title = {Understanding and {Using} {Patterns} in {Software} {Development}},
	volume = {2},
	copyright = {Copyright © 1996 John Wiley \& Sons, Inc.},
	issn = {1096-9942},
	optURL = {http://onlinelibrary.wiley.com/doi/10.1002/(SICI)1096-9942(1996)2:1<3::AID-TAPO1>3.0.CO;2-\#/abstract},
	optDoi = {10.1002/(SICI)1096-9942(1996)2:1 3::AID-TAPO1 3.0.CO;2-\#},
	abstract = {Patterns have shown to be an effective means of capturing and communicating software design experience. However, there is more to patterns than software design patterns: We believe that patterns work for software development on several levels. In this article we explore what we have come to understand as crucial aspects of the pattern concept, relate patterns to the different models built during software design, discuss pattern forms and how we think that patterns can form larger wholes like pattern handbooks. © 1996 John Wiley \& Sons, Inc.},
	language = {en},
	number = {1},
	urldate = {2016-06-04},
	journal = {Theory Pract. Obj. Syst.},
	author = {Riehle, Dirk and Züllighoven, Heinz},
	month = jan,
	year = {1996},
	pages = {3--13},
	optFile = {[PDF] from dirkriehle.com:/data/docs/refman/storage/6F7R2BQJ/Riehle and Züllighoven - 1996 - Understanding and using patterns in software devel.pdf:application/pdf;Snapshot:/data/docs/refman/storage/IAKZ595E/abstract.html:text/html}
}

@book{gamma_design_1994,
	address = {Reading, Mass},
	edition = {1st},
	title = {Design {Patterns}: {Elements} of {Reusable} {Object}-{Oriented} {Software}},
	isbn = {978-0-201-63361-0},
	shorttitle = {Design {Patterns}},
	abstract = {These texts cover the design of object-oriented software and examine how to investigate requirements, create solutions and then translate designs into code, showing developers how to make practical use of the most significant recent developments. A summary of UML notation is included.},
	language = {English},
	publisher = {Addison-Wesley Professional},
	author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John and Booch, Grady},
	month = nov,
	year = {1994},
	optFile = {DesignPatterns-Elements-of-reusable-object-oriented-software-Gamma et al 95.pdf:/data/docs/refman/storage/T9EU373Q/DesignPatterns-Elements-of-reusable-object-oriented-software-Gamma et al 95.pdf:application/pdf}
}

@incollection{kent_model_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Model {Driven} {Engineering}},
	copyright = {©2002 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-43703-1 978-3-540-47884-3},
	abstract = {The Object Management Group’s (OMG) Model Driven Architecture (MDA) strategy envisages a world where models play a more direct role in software production, being amenable to manipulation and transformation by machine. Model Driven Engineering (MDE) is wider in scope than MDA. MDE combines process and analysis with architecture. This article sets out a framework for model driven engineering, which can be used as a point of reference for activity in this area. It proposes an organisation of the modelling ‘space’ and how to locate models in that space. It discusses different kinds of mappings between models. It explains why process and architecture are tightly connected. It discusses the importance and nature of tools. It identifies the need for defining families of languages and transformations, and for developing techniques for generating/configuring tools from such definitions. It concludes with a call to align metamodelling with formal language engineering techniques.},
	language = {en},
	number = {2335},
	booktitle = {Integrated {Formal} {Methods}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kent, Stuart},
	editor = {Butler, Michael and Petre, Luigia and Sere, Kaisa},
	month = may,
	year = {2002},
	doi = {10.1007/3-540-47884-1_16},
	keywords = {Programming Languages, Compilers, Interpreters, Software Engineering, Logics and Meanings of Programs, Theory of Computation, Programming Techniques},
	pages = {286--298},
	file = {1_2002_MDE-Kent02.pdf:/data/docs/ref/seng/mdd_model-driven-development/1_2002_MDE-Kent02.pdf:application/pdf;Snapshot:/data/docs/refman/storage/W55AU3I7/3-540-47884-1_16.html:text/html}
}

@article{schmidt_model-driven_2006,
	title = {Model-{Driven} {Engineering}},
	volume = {39},
	issn = {0018-9162},
	url = {doi.ieeecomputersociety.org/10.1109/MC.2006.58},
	doi = {10.1109/MC.2006.58},
	journal = {Computer},
	author = {Schmidt, D. C.},
	year = {2006},
	keywords = {MDE tools, Software development, System design, Model-driven engineering, Enterprise DRE systems, Programming languages},
	pages = {25--31},
	file = {Schmidt - 2006 - Model-Driven Engineering.pdf:/data/docs/refman/storage/P3PYGP4E/Schmidt - 2006 - Model-Driven Engineering.pdf:application/pdf}
}

@book{brambilla_model-driven_2012,
	edition = {1st},
	title = {Model-{Driven} {Software} {Engineering} in {Practice}},
	isbn = {978-1-60845-882-0},
	optURL = {https://play.google.com/books/reader?id=ZbVdAQAAQBAJ&printsec=frontcover&output=reader&hl=en_GB&pg=GBS.PP1},	
	language = {English},
	publisher = {Morgan \& Claypool Publishers},
	author = {Brambilla, Marco and Cabot, Jordi and {Manuel Wimmer}},
	month = sep,
	year = {2012},
}

@incollection{stevens_landscape_2008,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Landscape} of {Bidirectional} {Model} {Transformations}},
	isbn = {978-3-540-88643-3},
	abstract = {Model transformations are a key element in the OMG’s Model Driven Development agenda. They did not begin here: the fundamental idea of transforming, automatically, one model into another is at least as old as the computer, provided that we take a sufficiently broad view of what a model is. In many contexts, people have encountered the need for bidirectional transformations. In this survey paper we discuss the various notions of bidirectional transformation, and their motivation from the needs of software engineering. We discuss the state of the art in work targeted specifically at the OMG’s MDD initiative, and also, briefly, related work from other communities. We point out some areas which are so far relatively under-researched, and propose research topics for the future.},
	language = {en},
	urldate = {2019-01-16},
	booktitle = {Generative and {Transformational} {Techniques} in {Software} {Engineering} {II}: {International} {Summer} {School}, {GTTSE} 2007, {Braga}, {Portugal}, {July} 2-7, 2007. {Revised} {Papers}},
	publisher = {Springer Berlin Heidelberg},
	author = {Stevens, Perdita},
	editor = {Lämmel, Ralf and Visser, Joost and Saraiva, João},
	year = {2008},
	doi = {10.1007/978-3-540-88643-3_10},
	keywords = {bidirectional model transformation, bidirectional programming language, graph transformation, QVT, triple graph grammar},
	pages = {408--424},
	file = {Stevens - 2008 - A Landscape of Bidirectional Model Transformations.pdf:/data/docs/refman/storage/5SFSQDQR/Stevens - 2008 - A Landscape of Bidirectional Model Transformations.pdf:application/pdf}
}

@inproceedings{warmer_model_2007,
	title = {A {Model} {Driven} {Software} {Factory} {Using} {Domain} {Specific} {Languages}},
	optURL = {https://link.springer.com/chapter/10.1007/978-3-540-72901-3_15},
	optDoi = {10.1007/978-3-540-72901-3\_15},
	abstract = {This paper describes the development of the SMART-Microsoft Software Factory. This factory is a fully model driven factory that makes extensive use of the Microsoft DSL Tools and is bases on the Microsoft Service Oriented Architecture. We describe the process used for developing the factory and share the experience gained in the first projects in which this factory has been used. The first project has 73\% of the delivered code being generated.},
	language = {en},
	urldate = {2017-04-04},
	booktitle = {Model {Driven} {Architecture}- {Foundations} and {Applications}},
	publisher = {Springer},
	author = {Warmer, Jos},
	month = jun,
	year = {2007},
	pages = {194--203},
	optFile = {Chapter 15 in Model Driven Architecture- Foundations and Application.pdf:/data/docs/refman/storage/VR4ZZKQZ/Chapter 15 in Model Driven Architecture- Foundations and Application.pdf:application/pdf;Snapshot:/data/docs/refman/storage/B948BAWW/978-3-540-72901-3_15.html:text/html}
}

@misc{warmer_building_2006,
	type = {Conference or {Workshop} {Paper}},
	title = {Building a {Flexible} {Software} {Factory} {Using} {Partial} {Domain} {Specific} {Models}},
	optURL = {http://eprints.eemcs.utwente.nl/6934/},
	abstract = {This paper describes some experiences in building a software factory by defining multiple small domain specific languages (DSLs) and having multiple small models per DSL. This is in high contrast with traditional approaches using
monolithic models, e.g. written in UML. In our approach, models behave like source code to a large extend, leading to an easy way to manage the model(s) of large systems.},
	urldate = {2017-04-12},
	author = {Warmer, Jos and Kleppe, Anneke},
	month = oct,
	year = {2006},
	optFile = {2-kleppe.pdf:/data/docs/refman/storage/EMAK35FE/2-kleppe.pdf:application/pdf;Snapshot:/data/docs/refman/storage/7DPHHNMW/6934.html:text/html}
}

@incollection{wada_modeling_2005,
	series = {{LNCS 3713}},
	title = {Modeling {Turnpike} {Frontend} {System}: {A} {Model}-{Driven} {Development} {Framework} {Leveraging} {UML} {Metamodeling} and {Attribute}-{Oriented} {Programming}},
	optcopyright = {©2005 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-29010-0 978-3-540-32057-9},
	shorttitle = {Modeling {Turnpike} {Frontend} {System}},
	opturl = {http://link.springer.com/chapter/10.1007/11557432_44},
	abstract = {This paper describes and empirically evaluates a new model-driven development framework, called Modeling Turnpike (or mTurnpike). It allows developers to model and program domain-specific concepts (ideas and mechanisms specific to a particular business or technology domain) and to transform them to the final (compilable) source code. By leveraging UML metamodeling and attribute-oriented programming, mTurnpike provides an abstraction to represent domain-specific concepts at the modeling and programming layers simultaneously. The mTurnpike frontend system transforms domain-specific concepts from the modeling layer to programming layer, and vise versa, in a seamless manner. Its backend system combines domain-specific models and programs, and transforms them to the final (compilable) source code. This paper focuses on the frontend system of mTurnpike, and describes its design, implementation and performance implications. In order to demonstrate how to exploit mTurnpike in application development, this paper also shows a development process using an example DSL (domain specific language) to specify service-oriented distributed systems.},
	language = {en},
	optnumber = {3713},
	urldate = {2016-12-02},
	booktitle = {MODELS},
	publisher = {Springer},
	author = {Wada, Hiroshi and Suzuki, Junichi},
	opteditor = {Briand, Lionel and Williams, Clay},
	month = oct,
	year = {2005},
	optdoi = {10.1007/11557432_44},
	keywords = {Programming Languages, Compilers, Interpreters, Software Engineering, Simulation and Modeling, Management of Computing and Information Systems},
	pages = {584--600},
	file = {Snapshot:/data/docs/refman/storage/46IR3FEG/10.html:text/html;wada2005.pdf:/data/docs/refman/storage/IMQTTT4Q/wada2005.pdf:application/pdf}
}

@book{cepa_attribute_2007,
	address = {Saarbrücken, Germany, Germany},
	title = {Attribute {Enabled} {Software} {Development}},
	isbn = {978-3-8364-1016-8},
	abstract = {Attribute Enabled Programming (AEP) is a wide-spreading technique that uses attributes to decorate existing code entities. AEP is supported in several general purpose languages, such as, .NET and Java, and by modeling languages, such as, MOF / UML. Attribute annotations may, however, fail to scale. Attribute dependencies complicate the interpretation and add-hoc solutions are difficult to maintain. A well defined development methodology that covers all the steps of Attribute Enabled Software Development (AESD) needs to be applied. This book focuses on the domain of mobile device software applications, based on Java Micro Edition (Java ME), and discusses the complete steps of applying AESD to model domain specific abstractions. Relation to product-lines is explored, and a concept of attribute-supported mobile containers to organize domain services, adapted from the enterprise containers, such as, Java EE and COM+, is presented. A structured methodology to transform attribute-based abstractions that warranties termination is introduced and illustrated. The book targets software professionals, and researchers in software engineering, programming languages, and graph transformations.},
	publisher = {VDM Verlag},
	author = {Cepa, Vasian},
	year = {2007}
}

@inproceedings{cepa_representing_2005,
	title = {Representing {Explicit} {Attributes} in {UML}},
	opturl = {http://dawis2.icb.uni-due.de/events/AOM_MODELS2005/Cepa.pdf},
	urldate = {2016-03-19},
	booktitle = {7th {Int.} {Workshop} on {AOM}},
	author = {Cepa, Vasian and Kloppenburg, Sven},
	year = {2005},
	file = {[PDF] from uni-due.de:/data/docs/refman/storage/UV7BPC8S/Cepa and Kloppenburg - 2005 - Representing explicit attributes in uml.pdf:application/pdf}
}

@article{sulir_recording_2016,
	title = {Recording {Concerns} in {Source} {Code} {Using} {Annotations}},
	volume = {46},
	issn = {1477-8424},
	opturl = {http://www.sciencedirect.com/science/article/pii/S147784241630015X},
	optdoi = {10.1016/j.cl.2016.07.003},
	abstract = {A concern can be characterized as a developer׳s intent behind a piece of code, often not explicitly captured in it. We discuss a technique of recording concerns using source code annotations (concern annotations). Using two studies and two controlled experiments, we seek to answer the following 3 research questions: (1) Do programmers׳ mental models overlap? (2) How do developers use shared concern annotations when they are available? (3) Does using annotations created by others improve program comprehension and maintenance correctness, time and confidence? The first study shows that developers׳ mental models, recorded using concern annotations, overlap and thus can be shared. The second study shows that shared concern annotations can be used during program comprehension for the following purposes: hypotheses confirmation, feature location, obtaining new knowledge, finding relationships and maintenance notes. The first controlled experiment with students showed that the presence of annotations significantly reduced program comprehension and maintenance time by 34\%. The second controlled experiment was a differentiated replication of the first one, focused on industrial developers. It showed a 33\% significant improvement in correctness. We conclude that concern annotations are a viable way to share developers׳ thoughts.},
	urldate = {2016-12-01},
	journal = {Computer Languages, Systems \& Structures},
	author = {Sulír, Matúš and Nosáľ, Milan and Porubän, Jaroslav},
	month = nov,
	year = {2016},
	keywords = {Program comprehension, Concerns, Source code annotations, Empirical studies},
	pages = {44--65},
	file = {Recording concerns in source code using annotations.pdf:/data/docs/refman/storage/UGBUAHR3/Recording concerns in source code using annotations.pdf:application/pdf;ScienceDirect Snapshot:/data/docs/refman/storage/HTFI6QX6/S147784241630015X.html:text/html}
}

@phdthesis{balz_embedding_2012,
	title = {Embedding {Model} {Specifications} in {Object}-{Oriented} {Program} {Code}: {A} {Bottom}-up {Approach} for {Model}-{Based} {Software} {Development}},
	opturl = {http://duepublico.uni-duisburg-essen.de/servlets/DocumentServlet?id=27160},
	abstract = {Models in software engineering are descriptive structures so that transformations can connect their contents at a semantic level. In model-based software development, algorithmic program code usually exists alongside models
- derived from them or with the purpose to amend them. While thus both kinds of notations must be considered by developers, no consistent mapping is given since
transformations between models and code are usually unidirectional for code generation. This impedes a continuous integration of both, limits the applicability of models, and prevents error tracking and monitoring at run time with respect to models. In this thesis, the approach of embedded models is introduced. Embedded models define patterns in program code whose elements have formal relations to models and can be executed by reflection at the same time. Model specifications are thus embedded in implementations and can be accessed by bidirectional transformations for design, verification, execution, and monitoring. The thesis focuses on the development of such patterns and their precise description as well as on the connection to other program code surrounding embedded models. Implementations are described for two modeling domains, state machines and process models, including tools for design, verification, execution, monitoring, and design recovery. The approach is evaluated with two case studies, the modeling of a real-world load generator for performance tests and the development of model-based educational graphical scenarios for university teaching. Both case studies show that the approach is valid and fulfills its purpose for a certain class of applications. Focusing on the integration in implementations, embedded models are thus a bottom-up approach for model-based software development.},
	language = {eng},
	urldate = {2016-12-02},
	school = {Universität Duisburg-Essen},
	author = {Balz, Moritz},
	month = jan,
	year = {2012},
	file = {Full Text PDF:/data/docs/refman/storage/532PIR2R/Balz - 2012 - Embedding model specifications in object-oriented .pdf:application/pdf;Snapshot:/data/docs/refman/storage/PDFV9H5K/DocumentServlet.html:text/html}
}

@inproceedings{kiczales_aspect-oriented_1997,
	series = {{LNCS}},
	title = {Aspect-oriented programming},
	copyright = {©1997 Springer-Verlag},
	isbn = {978-3-540-63089-0 978-3-540-69127-3},
	optURL = {http://link.springer.com/chapter/10.1007/BFb0053381},
	optDoi = {10.1007/BFb0053381},
	abstract = {We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in tangled code that is excessively difficult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspect-oriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code. The discussion is rooted in systems we have built using aspect-oriented programming.},
	language = {en},
	urldate = {2017-02-28},
	booktitle = {{ECOOP'97}-{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
	opteditor = {Akşit, Mehmet and Matsuoka, Satoshi},
	month = jun,
	year = {1997},
	keywords = {Database Management, Programming Languages, Compilers, Interpreters, Programming Techniques, Software Engineering},
	pages = {220--242},
	optFile = {Kiczales et al. - 1997 - Aspect-oriented programming.pdf:/data/docs/refman/storage/2HETU7WH/Kiczales et al. - 1997 - Aspect-oriented programming.pdf:application/pdf;Snapshot:/data/docs/refman/storage/PGJVCGDD/BFb0053381.html:text/html}
}

@techreport{chitchyan_survey_2015,
	type = {Report},
	title = {Survey of {Aspect}-{Oriented} {Analysis} and {Design} {Approaches}},
	optURL = {https://lra.le.ac.uk/handle/2381/32112},
	abstract = {A number of Aspect-Oriented (AO) Requirements, Architecture, and Design approaches have emerged recently. In this report we survey the most significant of these approaches, considering their origins, aims, and contributions. Alongside the AO approaches, we also analyse some of the contemporary non-AO work in order to bring out the differences between two sets of techniques, and to understand the potential contributions of aspect-oriented analysis and design. We also provide some initial insights into processes for AO requirements engineering, analysis and design which may serve as basis for integration of the work of the AOSD- EUROPE project partners. We also outline some issues relevant to such integration.},
	language = {en},
	urldate = {2017-02-28},
	author = {Chitchyan, Ruzanna and Rashid, A. and Sawyer, P. and Garcia, A. and Alarcon, M. P. and Bakker, J. and Tekinerdogan, B. and Clarke, S. and Jackson, A.},
	month = may,
	year = {2015},
	optFile = {Full Text PDF:/data/docs/refman/storage/IXCT8GW2/Chitchyan et al. - 2015 - Survey of Aspect-Oriented Analysis and Design Appr.pdf:application/pdf;Snapshot:/data/docs/refman/storage/AAZ48T43/32112.html:text/html}
}

@incollection{boyd_comparing_2005,
	series = {LNCS},
	title = {Comparing and {Transforming} {Between} {Data} {Models} {Via} an {Intermediate} {Hypergraph} {Data} {Model}},
	copyright = {©2005 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-31001-3 978-3-540-31447-9},
	opturl = {http://link.springer.com/chapter/10.1007/11603412_3},
	abstract = {Data integration is frequently performed between heterogeneous data sources, requiring that not only a schema, but also the data modelling language in which that schema is represented must be transformed between one data source and another. This paper describes an extension to the hypergraph data model (HDM), used in the AutoMed data integration approach, that allows constraint constructs found in static data modelling languages to be represented by a small set of primitive constraint operators in the HDM. In addition, a set of five equivalence preserving transformation rules are defined that operate over this extended HDM. These transformation rules are shown to allow a bidirectional mapping to be defined between equivalent relational, ER, UML and ORM schemas. The approach we propose provides a precise framework in which to compare data modelling languages, and precisely identifies what semantics of a particular domain one data model may express that another data model may not express. The approach also forms the platform for further work in automating the process of transforming between different data modelling languages. The use of the both-as-view approach to data integration means that a bidirectional association is produced between schemas in the data modelling language. Hence a further advantage of the approach is that composition of data mappings may be performed such that mapping two schemas to one common schema will produce a bidirectional mapping between the original two data sources.},
	language = {en},
	number = {3730},
	urldate = {2017-02-21},
	booktitle = {Journal on {Data} {Semantics} {IV}},
	publisher = {Springer Berlin Heidelberg},
	author = {Boyd, Michael and McBrien, Peter},
	opteditor = {Spaccapietra, Stefano},
	year = {2005},
	optdoi = {10.1007/11603412_3},
	keywords = {Artificial Intelligence (incl. Robotics), Database Management, Information Storage and Retrieval, Information Systems Applications (incl. Internet), Computer Communication Networks, conceptual data modelling, mappings, transformations, multiple representations},
	pages = {69--109},
	file = {boyd2005.pdf:/data/docs/refman/storage/CVVCNNKH/boyd2005.pdf:application/pdf;Snapshot:/data/docs/refman/storage/B8AFNS6S/11603412_3.html:text/html}
}

@book{eriksson_business_1998,
	address = {New York, NY, USA},
	edition = {1st},
	title = {Business {Modeling} {With} {UML}: {Business} {Patterns} at {Work}},
	isbn = {978-0-471-29551-8},
	shorttitle = {Business {Modeling} {With} {UML}},
	abstract = {From the Publisher:Eriksson and Magnus Penker now provide guidance on how to use UML to model your business systems. In this book, key business modeling concepts are presented, including how to define Business Rules with UML's Object Constraint Language (OCL) and how to use business models with use cases. The authors then provide 26 valuable Business Patterns along with an e-business case study that utilizes the techniques and patterns discussed in the book.},
	publisher = {John Wiley \& Sons, Inc.},
	author = {Eriksson, Hans-Erik and Penker, Magnus},
	year = {1998},
	optFile = {[PDF] psu.edu:/data/docs/refman/storage/Z6V4KI59/Eriksson and Penker - Business modeling with UML.pdf:application/pdf}
}

@inproceedings{dumas_uml_2001,
	series = {{LNCS}},
	title = {{UML} {Activity} {Diagrams} as a {Workflow} {Specification} {Language}},
	copyright = {©2001 Springer-Verlag},
	isbn = {978-3-540-42667-7 978-3-540-45441-0},
	optURL = {http://link.springer.com/chapter/10.1007/3-540-45441-1_7},
	optDoi = {0.1007/3-540-45441-1_7},
	abstract = {If UML activity diagrams are to succeed as a standard in the area of organisational process modeling, they need to compare well to alternative languages such as those provided by commercial Workflow Management Systems. This paper examines the expressiveness and the adequacy of activity diagrams for workflow specification, by systematically evaluating their ability to capture a collection of workflow patterns. This analysis provides insights into the relative strengths and weaknesses of activity diagrams. In particular, it is shown that, given an appropriate clarification of their semantics, activity diagrams are able to capture situations arising in practice, which cannot be captured by most commercial Workflow Management Systems. On the other hand, the study shows that activity diagrams fail to capture some useful situations, thereby suggesting directions for improvement.},
	language = {en},
	urldate = {2017-01-12},
	booktitle = {{UML} 2001},
	publisher = {Springer},
	author = {Dumas, Marlon and Hofstede, Arthur H. M. ter},
	editor = {Gogolla, Martin and Kobryn, Cris},
	month = oct,
	year = {2001},
	keywords = {IT in Business, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, Software Engineering, Software Engineering/Programming and Operating Systems},
	pages = {76--90},
	optFile = {Snapshot:/data/docs/refman/storage/7B87W32M/3-540-45441-1_7.html:text/html}
}

@incollection{daw_extensible_2015,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Extensible} {Operational} {Semantics} for {UML} {Activity} {Diagrams}},
	copyright = {©2015 Springer International Publishing Switzerland},
	isbn = {978-3-319-22968-3 978-3-319-22969-0},
	abstract = {This paper presents an operational semantics for UML activity diagrams, which can be extended according to domain-specific needs. The purpose of this semantics is three-fold: to give a robust basis for verifying model correctness; to help validate model transformations; and to provide a well-formed basis for assessing whether a proposed extension/interpretation of the modeling language is consistent with the standard. The challenges of a general formal framework for UML models include the semi-formality of the semantics specification, the extensibility of the language, and (sometimes deliberate, sometimes accidental) under-specification of model behavior in the standard. We also propose the use of simulation relations to verify whether a language extension is consistent with the UML standard.},
	language = {en},
	number = {9276},
	urldate = {2017-01-12},
	booktitle = {Software {Engineering} and {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Daw, Zamira and Cleaveland, Rance},
	editor = {Calinescu, Radu and Rumpe, Bernhard},
	year = {2015},
	doi = {10.1007/978-3-319-22969-0_25},
	keywords = {Programming Languages, Compilers, Interpreters, Software Engineering, Mathematical Logic and Formal Languages, Logics and Meanings of Programs, Programming Techniques, Computer Communication Networks},
	pages = {360--368},
	file = {Daw and Cleaveland - 2015 - An Extensible Operational Semantics for UML Activi.pdf:/data/docs/refman/storage/ZZXTNHZS/Daw and Cleaveland - 2015 - An Extensible Operational Semantics for UML Activi.pdf:application/pdf;Snapshot:/data/docs/refman/storage/USURIQMP/978-3-319-22969-0_25.html:text/html}
}

@book{larman_applying_2004,
	address = {Upper Saddle River, NJ, USA},
	edition = {3rd},
	title = {Applying {UML} and {Patterns}: {An} {Introduction} to {Object}-{Oriented} {Analysis} and {Design} and {Iterative} {Development}},
	isbn = {978-0-13-148906-6},
	shorttitle = {Applying {UML} and {Patterns}},
	publisher = {Prentice Hall PTR},
	author = {Larman, Craig},
	year = {2004},
	file = {applying-uml-and-patterns-2nd.pdf:/data/docs/refman/storage/VNXBXUI3/applying-uml-and-patterns-2nd.pdf:application/pdf;applying-uml-and-patterns-3rd.pdf:/data/docs/refman/storage/HNF6A4ZR/applying-uml-and-patterns-3rd.pdf:application/pdf}
}


@article{beck_manifesto_2017,
	title = {Manifesto for {Agile} {Software} {Development}},
	urldate = {2017-09-04},
	author = {Beck, K and Beedle, M and van Bennekum, A and Cockburn, A and Cunningham, W and Fowler, M and Grenning, J and Highsmith, J and Hunt, A and Jeffries, R},
	year = {2017},
	file = {Manifesto for Agile Software Development.pdf:/data/docs/refman/storage/C6P4BZJ4/Manifesto for Agile Software Development.pdf:application/pdf}
}

@inproceedings{lamsweerde_formal_2000,
	address = {New York, NY, USA},
	series = {{ICSE} '00},
	title = {Formal {Specification}: {A} {Roadmap}},
	isbn = {978-1-58113-253-3},
	shorttitle = {Formal {Specification}},
	opturl = {http://doi.acm.org/10.1145/336512.336546},
	optdoi = {10.1145/336512.336546},
	urldate = {2016-10-11},
	booktitle = {Proceedings of the {Conference} on {The} {Future} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Lamsweerde, Axel van},
	year = {2000},
	pages = {147--159},
	optfile = {ACM Full Text PDF:/data/docs/refman/storage/AJ9AH9HG/Lamsweerde - 2000 - Formal Specification A Roadmap.pdf:application/pdf}
}


@article{folmer_architecting_2004,
	title = {Architecting for {Usability}: {A} {Survey}},
	volume = {70},
	issn = {0164-1212},
	shorttitle = {Architecting for usability},
	doi = {10.1016/S0164-1212(02)00159-0},
	abstract = {Over the years the software engineering community has increasingly realized the important role software architecture plays in fulfilling the quality requirements of a system. The quality attributes of a software system are, to a large extent determined by the system’s software architecture. In recent years, the software engineering community has developed various tools and techniques that allow for design for quality attributes, such as performance or maintainability, at the software architecture level. We believe this design approach can be applied not only to “traditional” quality attributes such as performance or maintainability but also to usability. This survey explores the feasibility of such a design approach. Current practice is surveyed from the perspective of a software architect. Are there any design methods that allow for design for usability at the architectural level? Are there any evaluation tools that allow assessment of architectures for their support of usability? What is usability? A framework is presented which visualizes these three research questions. Usability should drive design at all stages, but current usability engineering practice fails to fully achieve this goal. Our survey shows that there are no design techniques or assessment tools that allow for design for usability at the architectural level.},
	number = {1–2},
	urldate = {2016-03-18},
	journal = {Journal of Systems and Software},
	author = {Folmer, Eelke and Bosch, Jan},
	month = feb,
	year = {2004},
	keywords = {Usability, Design for quality attributes, software architecture},
	pages = {61--78},
	file = {architecture-evaluation-survey.pdf:/data/docs/ref/seng/architecture/architecture-evaluation-survey.pdf:application/pdf;ScienceDirect Snapshot:/data/docs/refman/storage/RKZI4XQD/S0164121202001590.html:text/html}
}


@misc{weisstein_bijective_2018,
	type = {Text},
	title = {Bijective},
	copyright = {Copyright 1999-2018 Wolfram Research, Inc.  See http://mathworld.wolfram.com/about/terms.html for a full terms of use statement.},
	url = {http://mathworld.wolfram.com/Bijective.html},
	abstract = {A map is called bijective if it is both injective and surjective. A bijective map is also called a bijection. A function f admits an inverse f{\textasciicircum}(-1) (i.e., "f is invertible") iff it is bijective. Two sets X and Y are called bijective if there is a bijective map from X to Y. In this sense, "bijective" is a synonym for "equipollent" (or "equipotent"). Bijectivity is an equivalence relation on the class of sets.},
	language = {en},
  year = {2018},
	urldate = {2018-10-25},
	author = {Weisstein, Eric W.},
	file = {Snapshot:/data/docs/refman/storage/V8VM2K3R/Bijective.html:text/html}
}

@book{aprende_OpenXava_2011,
  title={Aprende OpenXava con ejemplos},
  url={https://books.google.com.vn/books?id=5GnQcZvDkbkC},
  publisher={Javier Paniza}
}


@article{haywood2013apache,
  title={Apache Isis-developing domain-driven Java apps},
  author={Haywood, Dan},
  journal={Methods \& Tools: Practical knowledge source for software development professionals},
  volume={21},
  number={2},
  pages={40--59},
  year={2013}
}

@article{thakur2019role,
  title={The role of model-view controller in object oriented software development},
  author={Thakur, Ram Naresh and Pandey, US},
  journal={Nepal Journal of Multidisciplinary Research},
  volume={2},
  number={2},
  pages={1--6},
  year={2019}
}

@inproceedings{dhingra2016performance,
  title={Performance Evaluation of JPA Based ORM Techniques},
  author={Dhingra, Neha and Abdelmoghith, Dr Emad and Mouftah, Dr Hussein T},
  booktitle={Proceedings of 2nd International Conference on Computer Science Networks and Information Technology, Heldon 27th-28th Aug},
  year={2016}
}

@inproceedings{pllana2018performance,
  title={Performance Analysis of Java Persistence API Providers},
  author={Pllana, Besart},
  booktitle={Conference Book of Proceedings},
  pages={100},
  year={2018}
}
@article{juneau2018bean,
  title={Bean Validation},
  author={Juneau, Josh and Juneau, Josh},
  journal={Java EE 8 Recipes: A Problem-Solution Approach},
  pages={507--522},
  year={2018},
  publisher={Springer}
}

@article{panizaopenxava,
  title={OpenXava (2021)},
  author={Paniza, Javier},
  journal={URL: http://openxava. org}
}
@book{keith2011pro,
  title={Pro JPA 2: Mastering the JavaTM Persistence API},
  author={Keith, Mike and Schincariol, Merrick and Keith, Jeremy},
  year={2011},
  publisher={Apress}
}

@book{ezzio2008using,
  title={Using and Understanding Java Data Objects},
  author={Ezzio, David},
  year={2008},
  publisher={Apress}
}

@article{validator2009hibernate,
  title={Hibernate Validator},
  author={Validator, Hibernate},
  journal={Available on http://www. hibernate. org/412. html},
  year={2009}
}

@misc{beanvalidation3,
	title = {Jakarta Bean Validation 3.0},
	url = {https://beanvalidation.org/3.0/},
	year={2020}

}
